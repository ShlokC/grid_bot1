
"""
Adaptive Crypto Signal System - QQE & Supertrend Focused Strategy
ENTRY SIGNALS ONLY - Relies on external SL/TP orders, but provides QQE/ST based exit *reasons*.
"""

import logging
import time
import os
import numpy as _np
_np.NaN = _np.nan
import numpy as np
import pandas as pd
import pandas_ta as ta
from typing import Dict, Optional
from collections import deque
from dataclasses import dataclass
import json

logging.basicConfig(
        level=logging.DEBUG,  # Set the minimum level for the root logger
        format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
    )
logging.getLogger(__name__).setLevel(logging.DEBUG) 
@dataclass
class SignalParameters:
    """Parameters for QQE & Supertrend signals"""
    qqe_length: int = 14
    qqe_smooth: int = 5
    qqe_factor: float = 4.236
    supertrend_period: int = 10 
    supertrend_multiplier: float = 3.0
    
    accuracy: float = 0.0
    total_signals: int = 0
    winning_signals: int = 0
    last_used: float = 0.0

    
class AdaptiveCryptoSignals:
    """
    QQE-primary signal system with Supertrend confirmation.
    Fisher Transform and VWAP components have been removed for simplification.
    """
    
    def __init__(self, symbol: str, config_file: str = "data/crypto_signal_configs.json"):
        self.logger = logging.getLogger(f"{__name__}.{symbol}") # Symbol specific logger
        self.symbol = symbol
        self.config_file = config_file
        self.position_entry_time = 0 # Initialize this attribute
        self.params = self._load_symbol_config()
        
        self.signal_performance = self._load_signal_history()
        self.last_signal = 'none'
        self.last_signal_time = 0
        self.signal_cooldown = 15 
        self.signal_stability_period = 30 
        
        self.current_trend = 'neutral' 
        self.volatility_level = 'normal' 
        self.last_optimization = time.time()
        
        self.min_signals_for_optimization = 5 
        self.optimization_interval = 300
        
        self.qqe_long_entry_max_zone = 80.0   # Increased from 65.0
        self.qqe_short_entry_min_zone = 20.0  # Decreased from 35.0

        self.last_indicators: Dict[str, Optional[Dict]] = {'qqe': None, 'supertrend': None}

        self.logger.info(f"üöÄ Adaptive Crypto Signals (QQE & Supertrend ONLY) initialized for {symbol} "
                        f"[QQE:{self.params.qqe_length},{self.params.qqe_smooth}, ST:{self.params.supertrend_period},{self.params.supertrend_multiplier}] "
                        f"[Accuracy: {self.params.accuracy:.1f}%]")

    def get_technical_direction(self, exchange) -> str:
        try:
            current_time = time.time()
            self.logger.info(f"[{self.symbol}] Checking technical direction. Last signal: {self.last_signal} at {self.last_signal_time}, Cooldown: {self.signal_cooldown}")
            if hasattr(self, '_force_signal') and self._force_signal: pass 
            elif current_time - self.last_signal_time < self.signal_cooldown: 
                self.logger.info(f"[{self.symbol}] Signal cooldown active. Returning 'none'.")
                return 'none'
            
            ohlcv_data = exchange.get_ohlcv(self.symbol, timeframe='3m', limit=1400) 
            if not ohlcv_data or len(ohlcv_data) < 50: 
                self.logger.info(f"[{self.symbol}] Insufficient data: {len(ohlcv_data) if ohlcv_data else 0} candles. Need >= 50.")
                return 'none'
            
            df = pd.DataFrame(ohlcv_data, columns=['timestamp', 'open', 'high', 'low', 'close', 'volume'])
            df['timestamp'] = pd.to_datetime(df['timestamp'], unit='ms')
            df = df.sort_values('timestamp').reset_index(drop=True)
            
            for col in ['open', 'high', 'low', 'close', 'volume']:
                df[col] = df[col].astype(float)
            
            df_indexed = df.set_index('timestamp')
            signal = self._generate_composite_signal(df_indexed) 
            
            if signal != 'none':
                self._track_signal(signal, float(df['close'].iloc[-1])) 
                self.last_signal = signal
                self.last_signal_time = current_time
                self.logger.info(f"‚ö° ENTRY SIGNAL: {signal.upper()} @ ${float(df['close'].iloc[-1]):.6f} "
                               f"[STrend: {self.current_trend}] [Vol: {self.volatility_level}] "
                               f"[Accuracy: {self.params.accuracy:.0f}%]")
            else:
                self.logger.info(f"[{self.symbol}] No signal generated by _generate_composite_signal.")

            if self._should_optimize():
                self._optimize_parameters(df.copy()) 
            
            return signal
        except Exception as e:
            self.logger.error(f"[{self.symbol}] ‚ùå Error generating signal: {e}", exc_info=True)
            return 'none'

    def _generate_composite_signal(self, df: pd.DataFrame) -> str:
        """SIMPLIFIED: Clear signal logic using fixed indicators."""
        try:
            self.logger.info(f"[{self.symbol}] --- Generating Signal ---")
            
            qqe_result = self._calculate_qqe(df)
            supertrend_result = self._calculate_supertrend(df)

            if not qqe_result or not supertrend_result:
                missing = []
                if not qqe_result: missing.append("QQE")
                if not supertrend_result: missing.append("Supertrend")
                self.logger.info(f"[{self.symbol}] Missing indicators: {', '.join(missing)}")
                return 'none'
            
            # Store for exit evaluation
            self.last_indicators['qqe'] = qqe_result
            self.last_indicators['supertrend'] = supertrend_result
            
            # SIMPLE LOGIC: Both indicators must agree
            qqe_value = qqe_result['qqe_value']
            qqe_signal = qqe_result['qqe_signal_line_value']
            st_direction = supertrend_result['direction']
            
            qqe_bullish = qqe_value < qqe_signal  # QQE line above signal line
            qqe_bearish = qqe_value > qqe_signal  # QQE line below signal line
            st_up = st_direction == 'up'
            st_down = st_direction == 'down'
            
            self.logger.info(f"[{self.symbol}] QQE: {qqe_value:.2f} vs Signal: {qqe_signal:.2f} ‚Üí {'BULLISH' if qqe_bullish else 'BEARISH'}")
            self.logger.info(f"[{self.symbol}] Supertrend: {st_direction.upper()}")
            
            # ENTRY SIGNALS: Both must agree
            if qqe_bullish and st_up:
                self.logger.info(f"[{self.symbol}] üü¢ BUY SIGNAL: QQE bullish + ST up")
                return 'buy'
            elif qqe_bearish and st_down:
                self.logger.info(f"[{self.symbol}] üî¥ SELL SIGNAL: QQE bearish + ST down")
                return 'sell'
            else:
                self.logger.info(f"[{self.symbol}] ‚ùå NO SIGNAL: Indicators disagree (QQE: {'bull' if qqe_bullish else 'bear'}, ST: {st_direction})")
                return 'none'
                
        except Exception as e:
            self.logger.error(f"[{self.symbol}] Signal generation error: {e}", exc_info=True)
            return 'none'

    def evaluate_exit_conditions(self, position_side: str, entry_price: float, current_price: float) -> Dict:
        """SIMPLIFIED: Clear exit logic using fixed indicators."""
        try:
            result = {'should_exit': False, 'exit_reason': '', 'exit_urgency': 'none'}
            
            qqe_data = self.last_indicators.get('qqe')
            st_data = self.last_indicators.get('supertrend')
            
            if not qqe_data or not st_data:
                self.logger.warning(f"[{self.symbol}] Exit eval: Missing indicator data")
                return result

            # Calculate PnL
            pnl_pct = ((current_price - entry_price) / entry_price) * 100 if position_side == 'long' else ((entry_price - current_price) / entry_price) * 100
            
            # Emergency stop loss
            if pnl_pct < -2.0:
                result.update({
                    'should_exit': True,
                    'exit_reason': f"Emergency SL: {pnl_pct:.2f}% loss",
                    'exit_urgency': 'immediate'
                })
                return result

            # SIMPLE EXIT: Both indicators against position
            qqe_value = qqe_data['qqe_value']
            qqe_signal = qqe_data['qqe_signal_line_value']
            st_direction = st_data['direction']
            
            qqe_bullish = qqe_value < qqe_signal  # QQE line above signal line
            qqe_bearish = qqe_value > qqe_signal  # QQE line below signal line
            st_up = st_direction == 'up'
            st_down = st_direction == 'down'
            
            self.logger.info(f"[{self.symbol}] Exit eval for {position_side.upper()}: QQE={'bull' if qqe_bullish else 'bear'}, ST={st_direction}")
            
            if position_side == 'long' and (qqe_bearish or st_down):
                result.update({
                    'should_exit': True,
                    'exit_reason': f"LONG exit: QQE bearish + ST down (PnL: {pnl_pct:.2f}%)",
                    'exit_urgency': 'normal'
                })
            elif position_side == 'short' and (qqe_bullish or st_up):
                result.update({
                    'should_exit': True,
                    'exit_reason': f"SHORT exit: QQE bullish + ST up (PnL: {pnl_pct:.2f}%)",
                    'exit_urgency': 'normal'
                })
            
            if result['should_exit']:
                self.logger.info(f"[{self.symbol}] ‚úÖ EXIT TRIGGERED: {result['exit_reason']}")
            else:
                self.logger.info(f"[{self.symbol}] ‚ùå NO EXIT: Indicators not both against position")
            
            return result
            
        except Exception as e:
            self.logger.error(f"[{self.symbol}] Exit evaluation error: {e}", exc_info=True)
            return {'should_exit': False, 'exit_reason': 'Error', 'exit_urgency': 'none'}

    def _calculate_qqe(self, df: pd.DataFrame) -> Optional[Dict]:
        """FIXED: Robust QQE calculation with proper column handling."""
        try:
            # Call pandas_ta QQE
            qqe_result = ta.qqe(df['close'], 
                            length=self.params.qqe_length, 
                            smooth=self.params.qqe_smooth, 
                            factor=self.params.qqe_factor)
            
            if qqe_result is None or qqe_result.empty:
                self.logger.warning(f"[{self.symbol}] QQE calculation returned None/empty")
                return None
            
            # FIXED: Better column detection - pandas_ta returns specific column names
            # For QQE, typical columns are: QQE_14_5_4.236, QQE_14_5_4.236_RSIMA
            qqe_columns = list(qqe_result.columns)
            self.logger.debug(f"[{self.symbol}] QQE returned columns: {qqe_columns}")
            
            if len(qqe_columns) < 2:
                self.logger.error(f"[{self.symbol}] QQE returned insufficient columns: {qqe_columns}")
                return None
            
            # FIXED: Use actual column names instead of constructed names
            qqe_line_col = qqe_columns[0]  # Main QQE line (yellow)
            qqe_signal_col = qqe_columns[1]  # Signal line (blue)
            
            qqe_line = qqe_result[qqe_line_col].dropna()
            qqe_signal = qqe_result[qqe_signal_col].dropna()
            
            if len(qqe_line) < 3 or len(qqe_signal) < 3:
                self.logger.warning(f"[{self.symbol}] Insufficient QQE data: {len(qqe_line)}, {len(qqe_signal)}")
                return None
            
            # Get current values
            current_qqe = float(qqe_line.iloc[-1])
            current_signal = float(qqe_signal.iloc[-1])
            
            if pd.isna(current_qqe) or pd.isna(current_signal):
                self.logger.warning(f"[{self.symbol}] QQE values are NaN")
                return None
            
            # SIMPLIFIED: Just the essential data
            return {
                'qqe_value': current_qqe,
                'qqe_signal_line_value': current_signal,
                'qqe_direction': current_qqe - current_signal,  # Positive = bullish
                'raw_columns': qqe_columns  # For debugging
            }
            
        except Exception as e:
            self.logger.error(f"[{self.symbol}] QQE calculation error: {e}", exc_info=True)
            return None

    def _calculate_supertrend(self, df: pd.DataFrame) -> Optional[Dict]:
        """FIXED: Robust Supertrend calculation with proper column handling."""
        try:
            # Call pandas_ta Supertrend
            st_result = ta.supertrend(high=df['high'], low=df['low'], close=df['close'], 
                                    length=self.params.supertrend_period, 
                                    multiplier=self.params.supertrend_multiplier)
            
            if st_result is None or st_result.empty:
                self.logger.warning(f"[{self.symbol}] Supertrend calculation returned None/empty")
                return None
            
            # FIXED: Better column detection - pandas_ta returns specific columns
            # For Supertrend, typical columns are: SUPERT_10_3.0, SUPERTd_10_3.0, SUPERTl_10_3.0, SUPERTs_10_3.0
            st_columns = list(st_result.columns)
            self.logger.debug(f"[{self.symbol}] Supertrend returned columns: {st_columns}")
            
            # Find direction column (contains 'd' for direction)
            direction_col = None
            for col in st_columns:
                if 'SUPERTd' in col:
                    direction_col = col
                    break
            
            if direction_col is None:
                self.logger.error(f"[{self.symbol}] No Supertrend direction column found in: {st_columns}")
                return None
            
            st_direction = st_result[direction_col].dropna()
            
            if len(st_direction) < 3:
                self.logger.warning(f"[{self.symbol}] Insufficient Supertrend data: {len(st_direction)}")
                return None
            
            # Get current direction
            current_dir = int(st_direction.iloc[-1])
            prev_dir = int(st_direction.iloc[-2]) if len(st_direction) > 1 else current_dir
            
            # Convert to readable direction
            direction = 'up' if current_dir == 1 else 'down'
            just_changed = current_dir != prev_dir
            
            # SIMPLIFIED: Just the essential data
            return {
                'direction': direction,
                'current_value': current_dir,
                'just_changed': just_changed,
                'raw_columns': st_columns  # For debugging
            }
            
        except Exception as e:
            self.logger.error(f"[{self.symbol}] Supertrend calculation error: {e}", exc_info=True)
            return None
    def _update_volatility_level(self, df: pd.DataFrame): 
        try:
            atr = ta.atr(high=df['high'], low=df['low'], close=df['close'], length=14) 
            if atr is not None and len(atr.dropna()) > 0:
                curr_atr = float(atr.dropna().iloc[-1])
                price = float(df['close'].iloc[-1])
                if price == 0: self.volatility_level = 'normal'; return
                atr_pct = (curr_atr / price) * 100
                self.volatility_level = 'high' if atr_pct > 2.0 else 'low' if atr_pct < 0.5 else 'normal'
            else: self.volatility_level = 'normal'      
        except Exception: self.volatility_level = 'normal'

    def _track_signal(self, signal: str, price: float):
        try:
            signal_data = {
                'signal': signal, 'price': price, 'timestamp': time.time(),
                'params': { 
                    'qqe_length': self.params.qqe_length, 'qqe_smooth': self.params.qqe_smooth,
                    'supertrend_period': self.params.supertrend_period, 'supertrend_multiplier': self.params.supertrend_multiplier
                },
                'market_state': {'trend': self.current_trend, 'volatility': self.volatility_level}
            }
            self.signal_performance.append(signal_data)
            self._evaluate_signals()
            if len(self.signal_performance) % 5 == 0: self._save_config()
        except Exception as e: self.logger.error(f"[{self.symbol}] Error tracking signal: {e}", exc_info=True)

    def _evaluate_signals(self):
        try:
            current_time = time.time(); eval_period_s = 30 * 60; min_move_pct = 0.5; eval_count = 0
            for sig_data in list(self.signal_performance): 
                if sig_data.get('evaluated', False): continue
                if current_time - sig_data['timestamp'] < eval_period_s: continue
                
                fut_price = None; fut_ts = float('inf')
                for fut_cand in self.signal_performance:
                    cand_ts = fut_cand['timestamp']
                    if cand_ts >= (sig_data['timestamp'] + eval_period_s) and cand_ts < fut_ts:
                        fut_price = fut_cand['price']; fut_ts = cand_ts
                
                if fut_price is not None:
                    chg_pct = ((fut_price - sig_data['price']) / sig_data['price']) * 100 if sig_data['price'] != 0 else 0
                    sig_data['correct'] = (sig_data['signal'] == 'buy' and chg_pct > min_move_pct) or \
                                          (sig_data['signal'] == 'sell' and chg_pct < -min_move_pct)
                    sig_data['evaluated'] = True; sig_data['price_change_eval'] = chg_pct; eval_count += 1
            
            tot_eval = sum(1 for s in self.signal_performance if s.get('evaluated', False))
            tot_corr = sum(1 for s in self.signal_performance if s.get('correct', False))
            self.params.accuracy = (tot_corr / tot_eval) * 100 if tot_eval > 0 else 0.0
            self.params.total_signals = tot_eval; self.params.winning_signals = tot_corr
            if eval_count > 0: self.logger.info(f"[{self.symbol}] Evaluated {eval_count} signals. Accuracy: {self.params.accuracy:.2f}%")
        except Exception as e: self.logger.error(f"[{self.symbol}] Error evaluating signals: {e}", exc_info=True)

    def _should_optimize(self) -> bool:
        curr_time = time.time()
        if curr_time - self.last_optimization < self.optimization_interval: return False
        if self.params.total_signals >= self.min_signals_for_optimization and self.params.accuracy < 45.0: return True
        return False

    def _optimize_parameters(self, df: pd.DataFrame):
        try:
            self.logger.info(f"[{self.symbol}] üîß Optimizing QQE & ST parameters...")
            param_ranges = {
                'qqe_length': [10, 14, 20], 'qqe_smooth': [3, 5, 7],
                'supertrend_period': [7, 10, 14], 'supertrend_multiplier': [2.0, 3.0]
            }
            best_score = -1.0; best_params_dict = None; num_combos = 0

            for q_len in param_ranges['qqe_length']:
              for q_sm in param_ranges['qqe_smooth']:
                for st_p in param_ranges['supertrend_period']:
                  for st_m in param_ranges['supertrend_multiplier']:
                    num_combos +=1
                    test_p = SignalParameters( qqe_length=q_len, qqe_smooth=q_sm,
                                               supertrend_period=st_p, supertrend_multiplier=st_m)
                    score = self._quick_backtest(df.copy(), test_p) 
                    self.logger.info(f"[{self.symbol}] Opt Test: Q({q_len},{q_sm}), ST({st_p},{st_m}) -> Score: {score:.2f}%")
                    if score > best_score:
                        best_score = score
                        best_params_dict = {
                            'qqe_length': q_len, 'qqe_smooth': q_sm,
                            'supertrend_period': st_p, 'supertrend_multiplier': st_m
                        }
            
            self.logger.info(f"[{self.symbol}] Optimization tested {num_combos} combos. Best backtest score: {best_score:.2f}%")
            if best_params_dict and best_score > self.params.accuracy : # Only update if backtest score is better than current live accuracy
                self.logger.info(f"[{self.symbol}] üìà New best QQE/ST parameters found (Score: {best_score:.2f}% vs Current Acc: {self.params.accuracy:.2f}%). Updating live parameters.")
                self.params.qqe_length = best_params_dict['qqe_length']
                self.params.qqe_smooth = best_params_dict['qqe_smooth']
                self.params.supertrend_period = best_params_dict['supertrend_period']
                self.params.supertrend_multiplier = best_params_dict['supertrend_multiplier']
                self.params.accuracy = 0.0; self.params.total_signals = 0; self.params.winning_signals = 0 # Reset accuracy for new params
                self.params.last_used = time.time()
                self.signal_performance.clear()
                self._save_config()
            self.last_optimization = time.time()
        except Exception as e: self.logger.error(f"[{self.symbol}] Error optimizing parameters: {e}", exc_info=True)

    def _quick_backtest(self, df_hist: pd.DataFrame, params_to_test: SignalParameters) -> float:
        try:
            df_calc = df_hist.set_index('timestamp')
            qqe_bt_df = ta.qqe(df_calc['close'], length=params_to_test.qqe_length, smooth=params_to_test.qqe_smooth, factor=4.236)
            if qqe_bt_df is None or qqe_bt_df.empty or len(qqe_bt_df.columns) < 2: return 0.0
            df_calc['qqe_val'] = qqe_bt_df.iloc[:,0]
            df_calc['qqe_sig'] = qqe_bt_df.iloc[:,1]
            
            st_bt_df = ta.supertrend(df_calc['high'], df_calc['low'], df_calc['close'], 
                                   length=params_to_test.supertrend_period, multiplier=params_to_test.supertrend_multiplier)
            if st_bt_df is None or st_bt_df.empty: return 0.0
            st_dir_col = next((col for col in st_bt_df.columns if 'SUPERTd' in col), None)
            if not st_dir_col: return 0.0
            df_calc['st_dir'] = st_bt_df[st_dir_col]

            df_calc.dropna(inplace=True)
            if len(df_calc) < 30: return 0.0

            trades = 0; wins = 0; position = None; entry_price = 0.0
            tp_pct = 1.5; sl_pct = 1.0 

            for i in range(1, len(df_calc)):
                price = df_calc['close'].iloc[i]
                if position == 'long':
                    qqe_bear_cross = df_calc['qqe_val'].iloc[i] < df_calc['qqe_sig'].iloc[i] and \
                                     df_calc['qqe_val'].iloc[i-1] >= df_calc['qqe_sig'].iloc[i-1]
                    if price >= entry_price * (1 + tp_pct/100) or qqe_bear_cross:
                        wins += 1 if (price >= entry_price * (1 + tp_pct/100) or (qqe_bear_cross and price > entry_price)) else 0
                        trades += 1; position = None; continue
                    elif price <= entry_price * (1 - sl_pct/100):
                        trades += 1; position = None; continue
                elif position == 'short':
                    qqe_bull_cross = df_calc['qqe_val'].iloc[i] > df_calc['qqe_sig'].iloc[i] and \
                                     df_calc['qqe_val'].iloc[i-1] <= df_calc['qqe_sig'].iloc[i-1]
                    if price <= entry_price * (1 - tp_pct/100) or qqe_bull_cross:
                        wins += 1 if (price <= entry_price * (1 - tp_pct/100) or (qqe_bull_cross and price < entry_price)) else 0
                        trades += 1; position = None; continue
                    elif price >= entry_price * (1 + sl_pct/100):
                        trades += 1; position = None; continue
                
                if not position:
                    cv, pv = df_calc['qqe_val'].iloc[i], df_calc['qqe_val'].iloc[i-1]
                    cs, ps = df_calc['qqe_sig'].iloc[i], df_calc['qqe_sig'].iloc[i-1]
                    b_x = pv <= ps and cv > cs; b_mom = cv > cs and cv > pv
                    s_x = pv >= ps and cv < cs; s_mom = cv < cs and cv < pv
                    qqe_long = b_x or b_mom; qqe_short = s_x or s_mom
                    st_up = df_calc['st_dir'].iloc[i] == 1
                    
                    if qqe_long and st_up and cv < self.qqe_long_entry_max_zone: # Using self. for zone defaults
                        position = 'long'; entry_price = price
                    elif qqe_short and not st_up and cv > self.qqe_short_entry_min_zone:
                        position = 'short'; entry_price = price
            return (wins / trades) * 100.0 if trades > 0 else 0.0
        except Exception as e:
            self.logger.error(f"[{self.symbol}] Error in _quick_backtest: {e}", exc_info=True)
            return 0.0

    def _load_symbol_config(self) -> SignalParameters:
        try:
            if os.path.exists(self.config_file):
                with open(self.config_file, 'r') as f: configs = json.load(f)
                if self.symbol in configs:
                    cfg = configs[self.symbol]
                    return SignalParameters(
                        qqe_length=cfg.get('qqe_length', SignalParameters.qqe_length),
                        qqe_smooth=cfg.get('qqe_smooth', SignalParameters.qqe_smooth),
                        qqe_factor=cfg.get('qqe_factor', SignalParameters.qqe_factor), # Safely get qqe_factor
                        supertrend_period=cfg.get('supertrend_period', SignalParameters.supertrend_period),
                        supertrend_multiplier=cfg.get('supertrend_multiplier', SignalParameters.supertrend_multiplier),
                        accuracy=cfg.get('accuracy', 0.0), total_signals=cfg.get('total_signals',0), 
                        winning_signals=cfg.get('winning_signals',0), last_used=cfg.get('last_used', 0.0)
                    )
        except Exception as e: self.logger.error(f"[{self.symbol}] Error loading config: {e}. Defaults used.", exc_info=True)
        return SignalParameters()

    def _load_signal_history(self) -> deque:
        try:
            if os.path.exists(self.config_file):
                with open(self.config_file, 'r') as f: configs = json.load(f)
                if self.symbol in configs:
                    hist = configs[self.symbol].get('signal_history', [])
                    return deque([item for item in hist if isinstance(item, dict)][-100:], maxlen=100)
        except Exception as e: self.logger.error(f"[{self.symbol}] Error loading history: {e}. Fresh history.", exc_info=True)
        return deque(maxlen=100)

    def _save_config(self):
        try:
            configs = {}
            if os.path.exists(self.config_file):
                try: 
                    with open(self.config_file, 'r') as f: configs = json.load(f)
                except json.JSONDecodeError: self.logger.warning(f"Config {self.config_file} corrupted. Overwriting."); configs = {}
            
            configs[self.symbol] = {
            'qqe_length': self.params.qqe_length, 
            'qqe_smooth': self.params.qqe_smooth, 
            'qqe_factor': self.params.qqe_factor, # Ensure it's saved
            'supertrend_period': self.params.supertrend_period, 
            'supertrend_multiplier': self.params.supertrend_multiplier,
            'accuracy': self.params.accuracy, 
            'total_signals': self.params.total_signals, 
            'winning_signals': self.params.winning_signals, 
            'last_used': self.params.last_used,
            'signal_history': list(self.signal_performance)[-100:], # Ensure deque is converted to list
            'last_updated': time.time()
        }
            config_dir = os.path.dirname(self.config_file)
            if config_dir and not os.path.exists(config_dir): os.makedirs(config_dir, exist_ok=True)
            temp_file = self.config_file + '.tmp'
            with open(temp_file, 'w') as f: json.dump(configs, f, indent=2)
            os.replace(temp_file, self.config_file)
        except Exception as e: self.logger.error(f"[{self.symbol}] Error saving config: {e}", exc_info=True)

    def get_system_status(self) -> Dict:
        return {
            'system_type': 'QQE_Supertrend_Only',
            'params': { 
                'qqe_length': self.params.qqe_length, 'qqe_smooth': self.params.qqe_smooth,
                'supertrend_period': self.params.supertrend_period, 'supertrend_multiplier': self.params.supertrend_multiplier,
            },
            'performance': {'accuracy': self.params.accuracy, 'total_signals': self.params.total_signals, 'winning_signals': self.params.winning_signals},
            'market_state': {'trend': self.current_trend, 'volatility': self.volatility_level}, 
            'last_signal_info': {'signal': self.last_signal, 'time': self.last_signal_time },
            'exit_logic_provider': 'External Strategy + QQE/ST reasons from this module'
        }

def integrate_adaptive_crypto_signals(strategy_instance, config_file: str = None):
    if config_file is None: config_file = os.path.join(os.getcwd(), "data", "crypto_signal_configs.json")
    strategy_instance.logger.info(f"üîß Integrating QQE & Supertrend ONLY Crypto Signals, config: {config_file}")
    base_sym = getattr(strategy_instance, 'original_symbol', strategy_instance.symbol)
    crypto_sigs = AdaptiveCryptoSignals(symbol=base_sym, config_file=config_file)
    
    strategy_instance._get_technical_direction = lambda: crypto_sigs.get_technical_direction(strategy_instance.exchange)
    strategy_instance.get_signal_status = crypto_sigs.get_system_status
    strategy_instance.test_crypto_indicators = lambda: crypto_sigs.test_indicators(strategy_instance.exchange)
    strategy_instance._crypto_signal_system = crypto_sigs
    
    try:
        strategy_instance.logger.info(f"Initial indicator test for {base_sym} (QQE/ST Only)...")
        test_res = strategy_instance.test_crypto_indicators()
        # Log test_res details if needed, for brevity, just confirming success/failure
        if isinstance(test_res, dict) and 'error' not in test_res:
             strategy_instance.logger.info(f"üìä Indicator Test (QQE/ST Only) for {base_sym} successful. Signal sim: {test_res.get('composite_signal_sim', 'N/A')}")
        else:
            strategy_instance.logger.warning(f"üìä Indicator Test (QQE/ST Only) for {base_sym} may have issues: {test_res}")

    except Exception as e: strategy_instance.logger.error(f"Failed initial indicator test (QQE/ST Only): {e}", exc_info=True)
    
    strategy_instance.logger.info("‚ö° QQE & Supertrend ONLY Crypto Signals integrated!")
    return crypto_sigs

def test_indicators(self: AdaptiveCryptoSignals, exchange) -> Dict:
    try:
        ohlcv = exchange.get_ohlcv(self.symbol, timeframe='3m', limit=300)
        if not ohlcv or len(ohlcv) < 50: return {'error': f'Insufficient data: {len(ohlcv) if ohlcv else 0}'}
        
        df = pd.DataFrame(ohlcv, columns=['timestamp', 'open', 'high', 'low', 'close', 'volume'])
        df['timestamp'] = pd.to_datetime(df['timestamp'], unit='ms')
        df_idx = df.set_index('timestamp')
        for col in ['open', 'high', 'low', 'close', 'volume']: df_idx[col] = df_idx[col].astype(float)

        res = {'symbol': self.symbol, 'price': float(df_idx['close'].iloc[-1]), 'data_points': len(df_idx)}
        res['qqe_calc_result'] = self._calculate_qqe(df_idx) or 'Failed QQE Calc' # Store full dict
        res['supertrend_calc_result'] = self._calculate_supertrend(df_idx) or 'Failed ST Calc' # Store full dict
        res['composite_signal_simulated'] = self._generate_composite_signal(df_idx) 
        res['current_market_trend_ST'] = self.current_trend 
        res['current_volatility_ATR'] = self.volatility_level 
        return res
    except Exception as e:
        self.logger.error(f"[{self.symbol}] Error in test_indicators (QQE/ST): {e}", exc_info=True)
        return {'error': str(e)}

AdaptiveCryptoSignals.test_indicators = test_indicators
integrate_crypto_signals = integrate_adaptive_crypto_signals

