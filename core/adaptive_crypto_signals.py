
"""
Adaptive Crypto Signal System - QQE & Supertrend Focused Strategy
ENTRY SIGNALS ONLY - Relies on external SL/TP orders, but provides QQE/ST based exit *reasons*.
"""

import logging
import time
import os
import numpy as _np
_np.NaN = _np.nan
import numpy as np
import pandas as pd
import pandas_ta as ta
from typing import Dict, Optional
from collections import deque
from dataclasses import dataclass
import json

logging.basicConfig(
        level=logging.DEBUG,  # Set the minimum level for the root logger
        format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
    )
logging.getLogger(__name__).setLevel(logging.DEBUG) 
@dataclass
class SignalParameters:
    """Parameters for QQE & Supertrend signals"""
    qqe_length: int = 14
    qqe_smooth: int = 5
    qqe_factor: float = 4.236
    supertrend_period: int = 10 
    supertrend_multiplier: float = 3.0
    
    accuracy: float = 0.0
    total_signals: int = 0
    winning_signals: int = 0
    last_used: float = 0.0

    
class AdaptiveCryptoSignals:
    """
    QQE-primary signal system with Supertrend confirmation.
    Fisher Transform and VWAP components have been removed for simplification.
    """
    
    def __init__(self, symbol: str, config_file: str = "data/crypto_signal_configs.json"):
        self.logger = logging.getLogger(f"{__name__}.{symbol}") # Symbol specific logger
        self.symbol = symbol
        self.config_file = config_file
        self.position_entry_time = 0 # Initialize this attribute
        self.params = self._load_symbol_config()
        
        self.signal_performance = self._load_signal_history()
        self.last_signal = 'none'
        self.last_signal_time = 0
        self.signal_cooldown = 15 
        self.signal_stability_period = 30 
        
        self.current_trend = 'neutral' 
        self.volatility_level = 'normal' 
        self.last_optimization = time.time()
        
        self.min_signals_for_optimization = 5 
        self.optimization_interval = 300
        
        self.qqe_long_entry_max_zone = 65.0
        self.qqe_short_entry_min_zone = 35.0

        self.last_indicators: Dict[str, Optional[Dict]] = {'qqe': None, 'supertrend': None}

        self.logger.info(f"ðŸš€ Adaptive Crypto Signals (QQE & Supertrend ONLY) initialized for {symbol} "
                        f"[QQE:{self.params.qqe_length},{self.params.qqe_smooth}, ST:{self.params.supertrend_period},{self.params.supertrend_multiplier}] "
                        f"[Accuracy: {self.params.accuracy:.1f}%]")

    def get_technical_direction(self, exchange) -> str:
        try:
            current_time = time.time()
            self.logger.info(f"[{self.symbol}] Checking technical direction. Last signal: {self.last_signal} at {self.last_signal_time}, Cooldown: {self.signal_cooldown}")
            if hasattr(self, '_force_signal') and self._force_signal: pass 
            elif current_time - self.last_signal_time < self.signal_cooldown: 
                self.logger.info(f"[{self.symbol}] Signal cooldown active. Returning 'none'.")
                return 'none'
            
            ohlcv_data = exchange.get_ohlcv(self.symbol, timeframe='3m', limit=1400) 
            if not ohlcv_data or len(ohlcv_data) < 50: 
                self.logger.info(f"[{self.symbol}] Insufficient data: {len(ohlcv_data) if ohlcv_data else 0} candles. Need >= 50.")
                return 'none'
            
            df = pd.DataFrame(ohlcv_data, columns=['timestamp', 'open', 'high', 'low', 'close', 'volume'])
            df['timestamp'] = pd.to_datetime(df['timestamp'], unit='ms')
            df = df.sort_values('timestamp').reset_index(drop=True)
            
            for col in ['open', 'high', 'low', 'close', 'volume']:
                df[col] = df[col].astype(float)
            
            df_indexed = df.set_index('timestamp')
            signal = self._generate_composite_signal(df_indexed) 
            
            if signal != 'none':
                self._track_signal(signal, float(df['close'].iloc[-1])) 
                self.last_signal = signal
                self.last_signal_time = current_time
                self.logger.info(f"âš¡ ENTRY SIGNAL: {signal.upper()} @ ${float(df['close'].iloc[-1]):.6f} "
                               f"[STrend: {self.current_trend}] [Vol: {self.volatility_level}] "
                               f"[Accuracy: {self.params.accuracy:.0f}%]")
            else:
                self.logger.info(f"[{self.symbol}] No signal generated by _generate_composite_signal.")

            if self._should_optimize():
                self._optimize_parameters(df.copy()) 
            
            return signal
        except Exception as e:
            self.logger.error(f"[{self.symbol}] âŒ Error generating signal: {e}", exc_info=True)
            return 'none'

    def _generate_composite_signal(self, df: pd.DataFrame) -> str:
        """Generate signal: QQE primary, Supertrend secondary. ADDED EXTENSIVE info LOGGING."""
        try:
            self.logger.info(f"[{self.symbol}] --- Generating Composite Signal ---")
            qqe_result = self._calculate_qqe(df)
            supertrend_result = self._calculate_supertrend(df)

            if qqe_result is None:
                self.logger.info(f"[{self.symbol}] QQE calculation failed or returned None. No signal.")
                self.last_indicators['qqe'] = None
                self.last_indicators['supertrend'] = supertrend_result # ST might still be valid
                return 'none'
            if supertrend_result is None:
                self.logger.info(f"[{self.symbol}] Supertrend calculation failed or returned None. No signal.")
                self.last_indicators['qqe'] = qqe_result # QQE might still be valid
                self.last_indicators['supertrend'] = None
                return 'none'
            
            self.last_indicators['qqe'] = qqe_result
            self.last_indicators['supertrend'] = supertrend_result

            self.current_trend = supertrend_result['direction']
            self._update_volatility_level(df) 
            
            self.logger.info(
                f"[{self.symbol}] Indicators Data: "
                f"QQE Val:{qqe_result['qqe_value']:.2f} (BullX:{qqe_result['is_bullish_cross']}, BearX:{qqe_result['is_bearish_cross']}, BullMom:{qqe_result['is_bullish_sustained_momentum']}, BearMom:{qqe_result['is_bearish_sustained_momentum']}), "
                f"STrend: {self.current_trend} (Changed:{supertrend_result['changed']})"
            )
            
            signal = 'none'
            current_qqe_value = qqe_result['qqe_value']
            is_primary_qqe_long = qqe_result['is_bullish_cross'] or qqe_result['is_bullish_sustained_momentum']
            is_primary_qqe_short = qqe_result['is_bearish_cross'] or qqe_result['is_bearish_sustained_momentum']

            self.logger.info(f"[{self.symbol}] Primary QQE Long: {is_primary_qqe_long} (Cross: {qqe_result['is_bullish_cross']}, SustainMom: {qqe_result['is_bullish_sustained_momentum']})")
            self.logger.info(f"[{self.symbol}] Primary QQE Short: {is_primary_qqe_short} (Cross: {qqe_result['is_bearish_cross']}, SustainMom: {qqe_result['is_bearish_sustained_momentum']})")

            time_since_last = time.time() - self.last_signal_time
            allow_opposite = True # Default to true if last_signal is 'none'
            if self.last_signal != 'none':
                allow_opposite = time_since_last >= self.signal_stability_period
            
            self.logger.info(f"[{self.symbol}] Last Signal: {self.last_signal}, Time Since: {time_since_last:.1f}s, Allow Opposite: {allow_opposite}, Stability Period: {self.signal_stability_period}s")


            if is_primary_qqe_long:
                self.logger.info(f"[{self.symbol}] Eval LONG: STrend dir: {supertrend_result['direction']}, QQE val: {current_qqe_value:.2f} vs max_zone: {self.qqe_long_entry_max_zone}")
                if supertrend_result['direction'] == 'up':
                    if current_qqe_value < self.qqe_long_entry_max_zone:
                        if not allow_opposite and self.last_signal == 'sell':
                            self.logger.info(f"[{self.symbol}] Skipping QQE Long: Stability period after SELL ({time_since_last:.1f}s)")
                        else:
                            signal = 'buy'
                            self.logger.info(f"[{self.symbol}] ðŸŸ¢ QQE Primary BUY SIGNAL: QQE Bullish, STrend UP, QQE Zone OK ({current_qqe_value:.2f} < {self.qqe_long_entry_max_zone})")
                    else: 
                        self.logger.info(f"[{self.symbol}] No Long Signal: QQE too high ({current_qqe_value:.2f} >= {self.qqe_long_entry_max_zone})")
                else: 
                    self.logger.info(f"[{self.symbol}] No Long Signal: Supertrend not UP (is {supertrend_result['direction']})")
            
            elif is_primary_qqe_short:
                self.logger.info(f"[{self.symbol}] Eval SHORT: STrend dir: {supertrend_result['direction']}, QQE val: {current_qqe_value:.2f} vs min_zone: {self.qqe_short_entry_min_zone}")
                if supertrend_result['direction'] == 'down':
                    if current_qqe_value > self.qqe_short_entry_min_zone:
                        if not allow_opposite and self.last_signal == 'buy':
                            self.logger.info(f"[{self.symbol}] Skipping QQE Short: Stability period after BUY ({time_since_last:.1f}s)")
                        else:
                            signal = 'sell'
                            self.logger.info(f"[{self.symbol}] ðŸ”´ QQE Primary SELL SIGNAL: QQE Bearish, STrend DOWN, QQE Zone OK ({current_qqe_value:.2f} > {self.qqe_short_entry_min_zone})")
                    else: 
                        self.logger.info(f"[{self.symbol}] No Short Signal: QQE too low ({current_qqe_value:.2f} <= {self.qqe_short_entry_min_zone})")
                else: 
                    self.logger.info(f"[{self.symbol}] No Short Signal: Supertrend not DOWN (is {supertrend_result['direction']})")
            else:
                self.logger.info(f"[{self.symbol}] No primary QQE signal (neither long nor short conditions met).")
            
            if signal == 'none':
                self.logger.info(f"[{self.symbol}] --- Composite Signal END: NONE ---")
            return signal
        except Exception as e:
            self.logger.error(f"[{self.symbol}] âŒ Error in _generate_composite_signal: {e}", exc_info=True)
            return 'none'

    def evaluate_exit_conditions(self, position_side: str, entry_price: float, current_price: float) -> Dict:
        try:
            result = {'should_exit': False, 'exit_reason': '', 'exit_urgency': 'none'}
            self.logger.info(f"[{self.symbol}] Evaluating exit for {position_side} @ entry ${entry_price:.6f}, current ${current_price:.6f}")
            
            qqe_data = self.last_indicators.get('qqe')
            st_data = self.last_indicators.get('supertrend')
            
            if not qqe_data or not st_data:
                self.logger.info(f"[{self.symbol}] Missing QQE or Supertrend data for exit eval.")
                return result

            pnl_pct = 0.0
            if entry_price != 0:
                pnl_pct = ((current_price - entry_price) / entry_price) * 100 if position_side == 'long' else ((entry_price - current_price) / entry_price) * 100
            
            entry_time = getattr(self, 'position_entry_time', 0) 
            position_age_seconds = time.time() - entry_time if entry_time > 0 else 99999
            min_pos_time_for_signal_exit = 60 

            if pnl_pct < -3.0: 
                result.update({'should_exit': True, 'exit_reason': f"EMERGENCY SL: PnL {pnl_pct:.2f}%", 'exit_urgency': 'immediate'})
                return result

            if position_side == 'long' and qqe_data.get('is_bearish_cross', False):
                if position_age_seconds >= min_pos_time_for_signal_exit or pnl_pct < -1.0: 
                    result.update({'should_exit': True, 'exit_reason': f"QQE Bearish Cross (PnL {pnl_pct:.2f}%)", 'exit_urgency': 'normal'})
                    return result
            elif position_side == 'short' and qqe_data.get('is_bullish_cross', False):
                 if position_age_seconds >= min_pos_time_for_signal_exit or pnl_pct < -1.0:
                    result.update({'should_exit': True, 'exit_reason': f"QQE Bullish Cross (PnL {pnl_pct:.2f}%)", 'exit_urgency': 'normal'})
                    return result

            if position_side == 'long' and st_data.get('direction') == 'down' and st_data.get('changed', False):
                 if position_age_seconds >= min_pos_time_for_signal_exit or pnl_pct < -0.5: 
                    result.update({'should_exit': True, 'exit_reason': f"Supertrend Flipped DOWN (PnL {pnl_pct:.2f}%)", 'exit_urgency': 'normal'})
                    return result
            elif position_side == 'short' and st_data.get('direction') == 'up' and st_data.get('changed', False):
                if position_age_seconds >= min_pos_time_for_signal_exit or pnl_pct < -0.5:
                    result.update({'should_exit': True, 'exit_reason': f"Supertrend Flipped UP (PnL {pnl_pct:.2f}%)", 'exit_urgency': 'normal'})
                    return result
            return result
        except Exception as e:
            self.logger.error(f"[{self.symbol}] âŒ Error evaluating exit conditions: {e}", exc_info=True)
            return {'should_exit': False, 'exit_reason': 'Error in eval', 'exit_urgency': 'none'}

    # In AdaptiveCryptoSignals class

    # In AdaptiveCryptoSignals class

    def _calculate_qqe(self, df: pd.DataFrame) -> Optional[Dict]:
        """
        Calculate QQE. Dynamically finds QQE and RSIMA columns.
        Uses qqe_factor from self.params.
        Corrected factor string formatting for column names.
        """
        try:
            qqe_df = ta.qqe(df['close'], 
                            length=self.params.qqe_length, 
                            smooth=self.params.qqe_smooth, 
                            factor=self.params.qqe_factor)
            
            if qqe_df is None or qqe_df.empty:
                self.logger.debug(f"[{self.symbol}] QQE calc: initial DataFrame from ta.qqe is None or empty.")
                return None

            # --- CORRECTED COLUMN NAME CONSTRUCTION ---
            # pandas-ta usually just stringifies the float for the name
            factor_str_for_name = str(self.params.qqe_factor) 
            
            base_col_name = f"QQE_{self.params.qqe_length}_{self.params.qqe_smooth}_{factor_str_for_name}"
            
            qqe_line_col_name = base_col_name
            qqe_signal_col_name = f"{base_col_name}_RSIMA"
            # --- END CORRECTION ---

            # self.logger.debug(f"[{self.symbol}] Attempting to find QQE columns: '{qqe_line_col_name}', '{qqe_signal_col_name}'")
            # self.logger.debug(f"[{self.symbol}] Available QQE columns from ta.qqe: {qqe_df.columns.tolist()}")


            if qqe_line_col_name not in qqe_df.columns:
                self.logger.warning(f"[{self.symbol}] Exact QQE line column '{qqe_line_col_name}' not found. Available: {qqe_df.columns.tolist()}. Falling back to positional index 0.")
                if len(qqe_df.columns) > 0: qqe_line_col_name = qqe_df.columns[0]
                else: 
                    self.logger.error(f"[{self.symbol}] QQE calc: No columns available in qqe_df after attempting to find line column.")
                    return None
            
            if qqe_signal_col_name not in qqe_df.columns:
                self.logger.warning(f"[{self.symbol}] Exact QQE RSIMA column '{qqe_signal_col_name}' not found. Available: {qqe_df.columns.tolist()}. Falling back to positional index 1.")
                if len(qqe_df.columns) > 1: qqe_signal_col_name = qqe_df.columns[1]
                else: 
                    self.logger.error(f"[{self.symbol}] QQE calc: Not enough columns available in qqe_df for RSIMA after attempting to find signal column.")
                    return None

            qqe_line_series_raw = qqe_df[qqe_line_col_name]
            qqe_signal_series_raw = qqe_df[qqe_signal_col_name]

            if len(qqe_line_series_raw) < 3 or len(qqe_signal_series_raw) < 3: 
                self.logger.debug(f"[{self.symbol}] QQE calc: Not enough raw data points. QQE line len: {len(qqe_line_series_raw)}, Sig line len: {len(qqe_signal_series_raw)}")
                return None
            
            cv_raw, pv_raw = qqe_line_series_raw.iloc[-1], qqe_line_series_raw.iloc[-2]
            cs_raw, ps_raw = qqe_signal_series_raw.iloc[-1], qqe_signal_series_raw.iloc[-2]
            
            if pd.isna(cv_raw) or pd.isna(pv_raw) or pd.isna(cs_raw) or pd.isna(ps_raw):
                self.logger.debug(f"[{self.symbol}] QQE calc: NaN found in latest required values. cv:{cv_raw}, pv:{pv_raw}, cs:{cs_raw}, ps:{ps_raw}")
                return None

            cv, pv = float(cv_raw), float(pv_raw)
            cs, ps = float(cs_raw), float(ps_raw)

            bull_x = (pv <= ps) and (cv > cs)
            bear_x = (pv >= ps) and (cv < cs)
            bull_mom = (cv > cs) and (cv > pv) 
            bear_mom = (cv < cs) and (cv < pv)

            s_dir = 'bull_mom' if cv > cs and cv > pv else 'bear_mom' if cv < cs and cv < pv else \
                      'bull_flat' if cv > cs else 'bear_flat' if cv < cs else 'neutral'
            return {
                'qqe_value': cv, 'qqe_signal_line_value': cs, 'prev_qqe_value': pv,
                'is_bullish_cross': bull_x, 'is_bearish_cross': bear_x,
                'is_bullish_sustained_momentum': bull_mom, 'is_bearish_sustained_momentum': bear_mom,
                'simple_direction': s_dir
            }
        except IndexError: 
            self.logger.debug(f"[{self.symbol}] QQE calc: IndexError during iloc access, series likely too short after initial check.")
            return None
        except Exception as e:
            self.logger.error(f"[{self.symbol}] QQE calculation error: {e}", exc_info=True)
            return None

    def _calculate_supertrend(self, df: pd.DataFrame) -> Optional[Dict]:
        try:
            st_df = ta.supertrend(high=df['high'], low=df['low'], close=df['close'], 
                               length=self.params.supertrend_period, 
                               multiplier=self.params.supertrend_multiplier)
            if st_df is None or st_df.empty:
                self.logger.info(f"[{self.symbol}] Supertrend calc: initial DataFrame from ta.supertrend is None or empty.")
                return None

            dir_col_name = f"SUPERTd_{self.params.supertrend_period}_{self.params.supertrend_multiplier}"
            if dir_col_name not in st_df.columns:
                dir_col_name = next((col for col in st_df.columns if 'SUPERTd' in col), None)
                if dir_col_name: self.logger.warning(f"[{self.symbol}] Exact ST dir col not found, using matched: '{dir_col_name}'")
                else: self.logger.warning(f"[{self.symbol}] ST dir col not found. Avail: {st_df.columns.tolist()}"); return None
            
            # Get the raw direction series
            st_directions_raw = st_df[dir_col_name]

            if len(st_directions_raw) < 2:
                self.logger.info(f"[{self.symbol}] Supertrend calc: Not enough raw direction data points. Len: {len(st_directions_raw)}")
                return None

            # Access the last 2 values
            curr_d_raw, prev_d_raw = st_directions_raw.iloc[-1], st_directions_raw.iloc[-2]

            # Check if these specific values are NaN
            if pd.isna(curr_d_raw) or pd.isna(prev_d_raw):
                self.logger.info(f"[{self.symbol}] Supertrend calc: NaN found in latest required values. current_dir:{curr_d_raw}, prev_dir:{prev_d_raw}")
                return None
            
            curr_d, prev_d = int(curr_d_raw), int(prev_d_raw)
            changed = curr_d != prev_d
            direction = 'up' if curr_d == 1 else 'down'
            return {'direction': direction, 'changed': changed, 'value': curr_d}
        except IndexError:
            self.logger.info(f"[{self.symbol}] Supertrend calc: IndexError during iloc access, series likely too short.")
            return None
        except Exception as e:
            self.logger.error(f"[{self.symbol}] Supertrend calculation error: {e}", exc_info=True)
            return None

    def _update_volatility_level(self, df: pd.DataFrame): 
        try:
            atr = ta.atr(high=df['high'], low=df['low'], close=df['close'], length=14) 
            if atr is not None and len(atr.dropna()) > 0:
                curr_atr = float(atr.dropna().iloc[-1])
                price = float(df['close'].iloc[-1])
                if price == 0: self.volatility_level = 'normal'; return
                atr_pct = (curr_atr / price) * 100
                self.volatility_level = 'high' if atr_pct > 2.0 else 'low' if atr_pct < 0.5 else 'normal'
            else: self.volatility_level = 'normal'      
        except Exception: self.volatility_level = 'normal'

    def _track_signal(self, signal: str, price: float):
        try:
            signal_data = {
                'signal': signal, 'price': price, 'timestamp': time.time(),
                'params': { 
                    'qqe_length': self.params.qqe_length, 'qqe_smooth': self.params.qqe_smooth,
                    'supertrend_period': self.params.supertrend_period, 'supertrend_multiplier': self.params.supertrend_multiplier
                },
                'market_state': {'trend': self.current_trend, 'volatility': self.volatility_level}
            }
            self.signal_performance.append(signal_data)
            self._evaluate_signals()
            if len(self.signal_performance) % 5 == 0: self._save_config()
        except Exception as e: self.logger.error(f"[{self.symbol}] Error tracking signal: {e}", exc_info=True)

    def _evaluate_signals(self):
        try:
            current_time = time.time(); eval_period_s = 30 * 60; min_move_pct = 0.5; eval_count = 0
            for sig_data in list(self.signal_performance): 
                if sig_data.get('evaluated', False): continue
                if current_time - sig_data['timestamp'] < eval_period_s: continue
                
                fut_price = None; fut_ts = float('inf')
                for fut_cand in self.signal_performance:
                    cand_ts = fut_cand['timestamp']
                    if cand_ts >= (sig_data['timestamp'] + eval_period_s) and cand_ts < fut_ts:
                        fut_price = fut_cand['price']; fut_ts = cand_ts
                
                if fut_price is not None:
                    chg_pct = ((fut_price - sig_data['price']) / sig_data['price']) * 100 if sig_data['price'] != 0 else 0
                    sig_data['correct'] = (sig_data['signal'] == 'buy' and chg_pct > min_move_pct) or \
                                          (sig_data['signal'] == 'sell' and chg_pct < -min_move_pct)
                    sig_data['evaluated'] = True; sig_data['price_change_eval'] = chg_pct; eval_count += 1
            
            tot_eval = sum(1 for s in self.signal_performance if s.get('evaluated', False))
            tot_corr = sum(1 for s in self.signal_performance if s.get('correct', False))
            self.params.accuracy = (tot_corr / tot_eval) * 100 if tot_eval > 0 else 0.0
            self.params.total_signals = tot_eval; self.params.winning_signals = tot_corr
            if eval_count > 0: self.logger.info(f"[{self.symbol}] Evaluated {eval_count} signals. Accuracy: {self.params.accuracy:.2f}%")
        except Exception as e: self.logger.error(f"[{self.symbol}] Error evaluating signals: {e}", exc_info=True)

    def _should_optimize(self) -> bool:
        curr_time = time.time()
        if curr_time - self.last_optimization < self.optimization_interval: return False
        if self.params.total_signals >= self.min_signals_for_optimization and self.params.accuracy < 45.0: return True
        return False

    def _optimize_parameters(self, df: pd.DataFrame):
        try:
            self.logger.info(f"[{self.symbol}] ðŸ”§ Optimizing QQE & ST parameters...")
            param_ranges = {
                'qqe_length': [10, 14, 20], 'qqe_smooth': [3, 5, 7],
                'supertrend_period': [7, 10, 14], 'supertrend_multiplier': [2.0, 3.0]
            }
            best_score = -1.0; best_params_dict = None; num_combos = 0

            for q_len in param_ranges['qqe_length']:
              for q_sm in param_ranges['qqe_smooth']:
                for st_p in param_ranges['supertrend_period']:
                  for st_m in param_ranges['supertrend_multiplier']:
                    num_combos +=1
                    test_p = SignalParameters( qqe_length=q_len, qqe_smooth=q_sm,
                                               supertrend_period=st_p, supertrend_multiplier=st_m)
                    score = self._quick_backtest(df.copy(), test_p) 
                    self.logger.info(f"[{self.symbol}] Opt Test: Q({q_len},{q_sm}), ST({st_p},{st_m}) -> Score: {score:.2f}%")
                    if score > best_score:
                        best_score = score
                        best_params_dict = {
                            'qqe_length': q_len, 'qqe_smooth': q_sm,
                            'supertrend_period': st_p, 'supertrend_multiplier': st_m
                        }
            
            self.logger.info(f"[{self.symbol}] Optimization tested {num_combos} combos. Best backtest score: {best_score:.2f}%")
            if best_params_dict and best_score > self.params.accuracy : # Only update if backtest score is better than current live accuracy
                self.logger.info(f"[{self.symbol}] ðŸ“ˆ New best QQE/ST parameters found (Score: {best_score:.2f}% vs Current Acc: {self.params.accuracy:.2f}%). Updating live parameters.")
                self.params.qqe_length = best_params_dict['qqe_length']
                self.params.qqe_smooth = best_params_dict['qqe_smooth']
                self.params.supertrend_period = best_params_dict['supertrend_period']
                self.params.supertrend_multiplier = best_params_dict['supertrend_multiplier']
                self.params.accuracy = 0.0; self.params.total_signals = 0; self.params.winning_signals = 0 # Reset accuracy for new params
                self.params.last_used = time.time()
                self.signal_performance.clear()
                self._save_config()
            self.last_optimization = time.time()
        except Exception as e: self.logger.error(f"[{self.symbol}] Error optimizing parameters: {e}", exc_info=True)

    def _quick_backtest(self, df_hist: pd.DataFrame, params_to_test: SignalParameters) -> float:
        try:
            df_calc = df_hist.set_index('timestamp')
            qqe_bt_df = ta.qqe(df_calc['close'], length=params_to_test.qqe_length, smooth=params_to_test.qqe_smooth, factor=4.236)
            if qqe_bt_df is None or qqe_bt_df.empty or len(qqe_bt_df.columns) < 2: return 0.0
            df_calc['qqe_val'] = qqe_bt_df.iloc[:,0]
            df_calc['qqe_sig'] = qqe_bt_df.iloc[:,1]
            
            st_bt_df = ta.supertrend(df_calc['high'], df_calc['low'], df_calc['close'], 
                                   length=params_to_test.supertrend_period, multiplier=params_to_test.supertrend_multiplier)
            if st_bt_df is None or st_bt_df.empty: return 0.0
            st_dir_col = next((col for col in st_bt_df.columns if 'SUPERTd' in col), None)
            if not st_dir_col: return 0.0
            df_calc['st_dir'] = st_bt_df[st_dir_col]

            df_calc.dropna(inplace=True)
            if len(df_calc) < 30: return 0.0

            trades = 0; wins = 0; position = None; entry_price = 0.0
            tp_pct = 1.5; sl_pct = 1.0 

            for i in range(1, len(df_calc)):
                price = df_calc['close'].iloc[i]
                if position == 'long':
                    qqe_bear_cross = df_calc['qqe_val'].iloc[i] < df_calc['qqe_sig'].iloc[i] and \
                                     df_calc['qqe_val'].iloc[i-1] >= df_calc['qqe_sig'].iloc[i-1]
                    if price >= entry_price * (1 + tp_pct/100) or qqe_bear_cross:
                        wins += 1 if (price >= entry_price * (1 + tp_pct/100) or (qqe_bear_cross and price > entry_price)) else 0
                        trades += 1; position = None; continue
                    elif price <= entry_price * (1 - sl_pct/100):
                        trades += 1; position = None; continue
                elif position == 'short':
                    qqe_bull_cross = df_calc['qqe_val'].iloc[i] > df_calc['qqe_sig'].iloc[i] and \
                                     df_calc['qqe_val'].iloc[i-1] <= df_calc['qqe_sig'].iloc[i-1]
                    if price <= entry_price * (1 - tp_pct/100) or qqe_bull_cross:
                        wins += 1 if (price <= entry_price * (1 - tp_pct/100) or (qqe_bull_cross and price < entry_price)) else 0
                        trades += 1; position = None; continue
                    elif price >= entry_price * (1 + sl_pct/100):
                        trades += 1; position = None; continue
                
                if not position:
                    cv, pv = df_calc['qqe_val'].iloc[i], df_calc['qqe_val'].iloc[i-1]
                    cs, ps = df_calc['qqe_sig'].iloc[i], df_calc['qqe_sig'].iloc[i-1]
                    b_x = pv <= ps and cv > cs; b_mom = cv > cs and cv > pv
                    s_x = pv >= ps and cv < cs; s_mom = cv < cs and cv < pv
                    qqe_long = b_x or b_mom; qqe_short = s_x or s_mom
                    st_up = df_calc['st_dir'].iloc[i] == 1
                    
                    if qqe_long and st_up and cv < self.qqe_long_entry_max_zone: # Using self. for zone defaults
                        position = 'long'; entry_price = price
                    elif qqe_short and not st_up and cv > self.qqe_short_entry_min_zone:
                        position = 'short'; entry_price = price
            return (wins / trades) * 100.0 if trades > 0 else 0.0
        except Exception as e:
            self.logger.error(f"[{self.symbol}] Error in _quick_backtest: {e}", exc_info=True)
            return 0.0

    def _load_symbol_config(self) -> SignalParameters:
        try:
            if os.path.exists(self.config_file):
                with open(self.config_file, 'r') as f: configs = json.load(f)
                if self.symbol in configs:
                    cfg = configs[self.symbol]
                    return SignalParameters(
                        qqe_length=cfg.get('qqe_length', SignalParameters.qqe_length),
                        qqe_smooth=cfg.get('qqe_smooth', SignalParameters.qqe_smooth),
                        qqe_factor=cfg.get('qqe_factor', SignalParameters.qqe_factor), # Safely get qqe_factor
                        supertrend_period=cfg.get('supertrend_period', SignalParameters.supertrend_period),
                        supertrend_multiplier=cfg.get('supertrend_multiplier', SignalParameters.supertrend_multiplier),
                        accuracy=cfg.get('accuracy', 0.0), total_signals=cfg.get('total_signals',0), 
                        winning_signals=cfg.get('winning_signals',0), last_used=cfg.get('last_used', 0.0)
                    )
        except Exception as e: self.logger.error(f"[{self.symbol}] Error loading config: {e}. Defaults used.", exc_info=True)
        return SignalParameters()

    def _load_signal_history(self) -> deque:
        try:
            if os.path.exists(self.config_file):
                with open(self.config_file, 'r') as f: configs = json.load(f)
                if self.symbol in configs:
                    hist = configs[self.symbol].get('signal_history', [])
                    return deque([item for item in hist if isinstance(item, dict)][-100:], maxlen=100)
        except Exception as e: self.logger.error(f"[{self.symbol}] Error loading history: {e}. Fresh history.", exc_info=True)
        return deque(maxlen=100)

    def _save_config(self):
        try:
            configs = {}
            if os.path.exists(self.config_file):
                try: 
                    with open(self.config_file, 'r') as f: configs = json.load(f)
                except json.JSONDecodeError: self.logger.warning(f"Config {self.config_file} corrupted. Overwriting."); configs = {}
            
            configs[self.symbol] = {
            'qqe_length': self.params.qqe_length, 
            'qqe_smooth': self.params.qqe_smooth, 
            'qqe_factor': self.params.qqe_factor, # Ensure it's saved
            'supertrend_period': self.params.supertrend_period, 
            'supertrend_multiplier': self.params.supertrend_multiplier,
            'accuracy': self.params.accuracy, 
            'total_signals': self.params.total_signals, 
            'winning_signals': self.params.winning_signals, 
            'last_used': self.params.last_used,
            'signal_history': list(self.signal_performance)[-100:], # Ensure deque is converted to list
            'last_updated': time.time()
        }
            config_dir = os.path.dirname(self.config_file)
            if config_dir and not os.path.exists(config_dir): os.makedirs(config_dir, exist_ok=True)
            temp_file = self.config_file + '.tmp'
            with open(temp_file, 'w') as f: json.dump(configs, f, indent=2)
            os.replace(temp_file, self.config_file)
        except Exception as e: self.logger.error(f"[{self.symbol}] Error saving config: {e}", exc_info=True)

    def get_system_status(self) -> Dict:
        return {
            'system_type': 'QQE_Supertrend_Only',
            'params': { 
                'qqe_length': self.params.qqe_length, 'qqe_smooth': self.params.qqe_smooth,
                'supertrend_period': self.params.supertrend_period, 'supertrend_multiplier': self.params.supertrend_multiplier,
            },
            'performance': {'accuracy': self.params.accuracy, 'total_signals': self.params.total_signals, 'winning_signals': self.params.winning_signals},
            'market_state': {'trend': self.current_trend, 'volatility': self.volatility_level}, 
            'last_signal_info': {'signal': self.last_signal, 'time': self.last_signal_time },
            'exit_logic_provider': 'External Strategy + QQE/ST reasons from this module'
        }

def integrate_adaptive_crypto_signals(strategy_instance, config_file: str = None):
    if config_file is None: config_file = os.path.join(os.getcwd(), "data", "crypto_signal_configs.json")
    strategy_instance.logger.info(f"ðŸ”§ Integrating QQE & Supertrend ONLY Crypto Signals, config: {config_file}")
    base_sym = getattr(strategy_instance, 'original_symbol', strategy_instance.symbol)
    crypto_sigs = AdaptiveCryptoSignals(symbol=base_sym, config_file=config_file)
    
    strategy_instance._get_technical_direction = lambda: crypto_sigs.get_technical_direction(strategy_instance.exchange)
    strategy_instance.get_signal_status = crypto_sigs.get_system_status
    strategy_instance.test_crypto_indicators = lambda: crypto_sigs.test_indicators(strategy_instance.exchange)
    strategy_instance._crypto_signal_system = crypto_sigs
    
    try:
        strategy_instance.logger.info(f"Initial indicator test for {base_sym} (QQE/ST Only)...")
        test_res = strategy_instance.test_crypto_indicators()
        # Log test_res details if needed, for brevity, just confirming success/failure
        if isinstance(test_res, dict) and 'error' not in test_res:
             strategy_instance.logger.info(f"ðŸ“Š Indicator Test (QQE/ST Only) for {base_sym} successful. Signal sim: {test_res.get('composite_signal_sim', 'N/A')}")
        else:
            strategy_instance.logger.warning(f"ðŸ“Š Indicator Test (QQE/ST Only) for {base_sym} may have issues: {test_res}")

    except Exception as e: strategy_instance.logger.error(f"Failed initial indicator test (QQE/ST Only): {e}", exc_info=True)
    
    strategy_instance.logger.info("âš¡ QQE & Supertrend ONLY Crypto Signals integrated!")
    return crypto_sigs

def test_indicators(self: AdaptiveCryptoSignals, exchange) -> Dict:
    try:
        ohlcv = exchange.get_ohlcv(self.symbol, timeframe='3m', limit=300)
        if not ohlcv or len(ohlcv) < 50: return {'error': f'Insufficient data: {len(ohlcv) if ohlcv else 0}'}
        
        df = pd.DataFrame(ohlcv, columns=['timestamp', 'open', 'high', 'low', 'close', 'volume'])
        df['timestamp'] = pd.to_datetime(df['timestamp'], unit='ms')
        df_idx = df.set_index('timestamp')
        for col in ['open', 'high', 'low', 'close', 'volume']: df_idx[col] = df_idx[col].astype(float)

        res = {'symbol': self.symbol, 'price': float(df_idx['close'].iloc[-1]), 'data_points': len(df_idx)}
        res['qqe_calc_result'] = self._calculate_qqe(df_idx) or 'Failed QQE Calc' # Store full dict
        res['supertrend_calc_result'] = self._calculate_supertrend(df_idx) or 'Failed ST Calc' # Store full dict
        res['composite_signal_simulated'] = self._generate_composite_signal(df_idx) 
        res['current_market_trend_ST'] = self.current_trend 
        res['current_volatility_ATR'] = self.volatility_level 
        return res
    except Exception as e:
        self.logger.error(f"[{self.symbol}] Error in test_indicators (QQE/ST): {e}", exc_info=True)
        return {'error': str(e)}

AdaptiveCryptoSignals.test_indicators = test_indicators
integrate_crypto_signals = integrate_adaptive_crypto_signals

