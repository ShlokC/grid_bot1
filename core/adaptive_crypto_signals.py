
"""
Adaptive Crypto Signal System - QQE & Supertrend Focused Strategy
ENTRY SIGNALS ONLY - Relies on external SL/TP orders, but provides QQE/ST based exit *reasons*.
"""

import logging
import time
import os
import numpy as _np
_np.NaN = _np.nan
import numpy as np
import pandas as pd
import pandas_ta as ta
from typing import Dict, Optional
from collections import deque
from dataclasses import dataclass
import json

logging.basicConfig(
        level=logging.DEBUG,  # Set the minimum level for the root logger
        format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
    )
logging.getLogger(__name__).setLevel(logging.DEBUG) 
@dataclass
class SignalParameters:
    """Parameters for QQE & Supertrend signals"""
    qqe_length: int = 14
    qqe_smooth: int = 5
    qqe_factor: float = 4.236
    supertrend_period: int = 10 
    supertrend_multiplier: float = 3.0
    
    accuracy: float = 0.0
    total_signals: int = 0
    winning_signals: int = 0
    last_used: float = 0.0

    
class AdaptiveCryptoSignals:
    """
    QQE-primary signal system with Supertrend confirmation.
    Fisher Transform and VWAP components have been removed for simplification.
    """
    
    def __init__(self, symbol: str, config_file: str = "data/crypto_signal_configs.json"):
        self.logger = logging.getLogger(f"{__name__}.{symbol}") # Symbol specific logger
        self.symbol = symbol
        self.config_file = config_file
        self.position_entry_time = 0 # Initialize this attribute
        self.params = self._load_symbol_config()
        
        self.signal_performance = self._load_signal_history()
        self.last_signal = 'none'
        self.last_signal_time = 0
        self.signal_cooldown = 15 
        self.signal_stability_period = 30 
        
        self.current_trend = 'neutral' 
        self.volatility_level = 'normal' 
        self.last_optimization = time.time()
        
        self.min_signals_for_optimization = 5 
        self.optimization_interval = 300
        
        self.qqe_long_entry_max_zone = 80.0   # Increased from 65.0
        self.qqe_short_entry_min_zone = 20.0  # Decreased from 35.0

        self.last_indicators: Dict[str, Optional[Dict]] = {'qqe': None, 'supertrend': None}

        self.logger.info(f"ðŸš€ Adaptive Crypto Signals (QQE & Supertrend ONLY) initialized for {symbol} "
                        f"[QQE:{self.params.qqe_length},{self.params.qqe_smooth}, ST:{self.params.supertrend_period},{self.params.supertrend_multiplier}] "
                        f"[Accuracy: {self.params.accuracy:.1f}%]")

    def get_technical_direction(self, exchange) -> str:
        try:
            current_time = time.time()
            self.logger.info(f"[{self.symbol}] Checking technical direction. Last signal: {self.last_signal} at {self.last_signal_time}, Cooldown: {self.signal_cooldown}")
            if hasattr(self, '_force_signal') and self._force_signal: pass 
            elif current_time - self.last_signal_time < self.signal_cooldown: 
                self.logger.info(f"[{self.symbol}] Signal cooldown active. Returning 'none'.")
                return 'none'
            
            ohlcv_data = exchange.get_ohlcv(self.symbol, timeframe='3m', limit=1400) 
            if not ohlcv_data or len(ohlcv_data) < 50: 
                self.logger.info(f"[{self.symbol}] Insufficient data: {len(ohlcv_data) if ohlcv_data else 0} candles. Need >= 50.")
                return 'none'
            
            df = pd.DataFrame(ohlcv_data, columns=['timestamp', 'open', 'high', 'low', 'close', 'volume'])
            df['timestamp'] = pd.to_datetime(df['timestamp'], unit='ms')
            df = df.sort_values('timestamp').reset_index(drop=True)
            
            for col in ['open', 'high', 'low', 'close', 'volume']:
                df[col] = df[col].astype(float)
            
            df_indexed = df.set_index('timestamp')
            signal = self._generate_composite_signal(df_indexed) 
            
            if signal != 'none':
                self._track_signal(signal, float(df['close'].iloc[-1])) 
                self.last_signal = signal
                self.last_signal_time = current_time
                self.logger.info(f"âš¡ ENTRY SIGNAL: {signal.upper()} @ ${float(df['close'].iloc[-1]):.6f} "
                               f"[STrend: {self.current_trend}] [Vol: {self.volatility_level}] "
                               f"[Accuracy: {self.params.accuracy:.0f}%]")
            else:
                self.logger.info(f"[{self.symbol}] No signal generated by _generate_composite_signal.")

            if self._should_optimize():
                self._optimize_parameters(df.copy()) 
            
            return signal
        except Exception as e:
            self.logger.error(f"[{self.symbol}] âŒ Error generating signal: {e}", exc_info=True)
            return 'none'

    def _generate_composite_signal(self, df: pd.DataFrame) -> str:
        """
        FIXED RESPONSIVE SIGNAL GENERATION with proper debugging and logic verification.
        """
        try:
            self.logger.info(f"[{self.symbol}] --- Responsive Signal Analysis ---")
            qqe_result = self._calculate_qqe(df)
            supertrend_result = self._calculate_supertrend(df)

            if qqe_result is None or supertrend_result is None:
                self.logger.info(f"[{self.symbol}] Missing indicators: QQE={qqe_result is not None}, ST={supertrend_result is not None}")
                return 'none'
            
            self.last_indicators['qqe'] = qqe_result
            self.last_indicators['supertrend'] = supertrend_result
            self.current_trend = supertrend_result['direction']
            self._update_volatility_level(df)
            
            current_qqe_value = qqe_result['qqe_value']
            
            # ENHANCED DEBUGGING: Show all the flags clearly
            self.logger.info(
                f"[{self.symbol}] DETAILED Analysis:"
            )
            self.logger.info(
                f"  QQE: Value={current_qqe_value:.2f}, Strength=[{qqe_result['signal_strength']}]"
            )
            self.logger.info(
                f"  QQE Flags: Imm_Bull={qqe_result['immediate_bullish']}, Imm_Bear={qqe_result['immediate_bearish']}"
            )
            self.logger.info(
                f"  QQE Flags: Fast_Bull={qqe_result['fast_bullish']}, Fast_Bear={qqe_result['fast_bearish']}"
            )
            self.logger.info(
                f"  QQE Flags: Conf_Bull={qqe_result['confirmed_bullish']}, Conf_Bear={qqe_result['confirmed_bearish']}"
            )
            self.logger.info(
                f"  ST: Direction={supertrend_result['direction']}, Strength=[{supertrend_result['trend_strength']}]"
            )
            self.logger.info(
                f"  ST Flags: Imm_Up={supertrend_result['immediate_up']}, Imm_Down={supertrend_result['immediate_down']}"
            )
            self.logger.info(
                f"  ST Flags: Fast_Up={supertrend_result['fast_up']}, Fast_Down={supertrend_result['fast_down']}"
            )
            self.logger.info(
                f"  ST Flags: Conf_Up={supertrend_result['confirmed_up']}, Conf_Down={supertrend_result['confirmed_down']}"
            )

            # Check signal stability
            time_since_last = time.time() - self.last_signal_time
            allow_opposite = self.last_signal == 'none' or time_since_last >= self.signal_stability_period

            signal = 'none'
            signal_tier = 'none'
            signal_reason = 'none'

            # FIXED LOGIC: Clear conditions with explicit checks
            
            # TIER 1: FAST SIGNALS (3-6 minutes delay max)
            if qqe_result['fast_bullish'] and supertrend_result['fast_up']:
                if current_qqe_value < self.qqe_long_entry_max_zone:
                    if allow_opposite or self.last_signal != 'sell':
                        signal = 'buy'
                        signal_tier = 'fast'
                        signal_reason = f"QQE fast bullish ({qqe_result['fast_bullish']}) + ST fast up ({supertrend_result['fast_up']})"
                        self.logger.info(f"[{self.symbol}] ðŸŸ¢ FAST BUY: {signal_reason}")
                    else:
                        self.logger.info(f"[{self.symbol}] FAST BUY blocked: Signal stability period")
                else:
                    self.logger.info(f"[{self.symbol}] FAST BUY blocked: QQE too high ({current_qqe_value:.2f} >= {self.qqe_long_entry_max_zone})")

            elif qqe_result['fast_bearish'] and supertrend_result['fast_down']:
                if current_qqe_value > self.qqe_short_entry_min_zone:
                    if allow_opposite or self.last_signal != 'buy':
                        signal = 'sell'
                        signal_tier = 'fast'
                        signal_reason = f"QQE fast bearish ({qqe_result['fast_bearish']}) + ST fast down ({supertrend_result['fast_down']})"
                        self.logger.info(f"[{self.symbol}] ðŸ”´ FAST SELL: {signal_reason}")
                    else:
                        self.logger.info(f"[{self.symbol}] FAST SELL blocked: Signal stability period")
                else:
                    self.logger.info(f"[{self.symbol}] FAST SELL blocked: QQE too low ({current_qqe_value:.2f} <= {self.qqe_short_entry_min_zone})")

            # TIER 2: CONFIRMED SIGNALS (only if no fast signal)
            if signal == 'none':
                # FIXED: Confirmed BUY - QQE confirmed BULLISH + ST confirmed UP
                if qqe_result['confirmed_bullish'] and supertrend_result['confirmed_up']:
                    if current_qqe_value < self.qqe_long_entry_max_zone:
                        if allow_opposite or self.last_signal != 'sell':
                            signal = 'buy'
                            signal_tier = 'confirmed'
                            signal_reason = f"QQE confirmed bullish ({qqe_result['confirmed_bullish']}) + ST confirmed up ({supertrend_result['confirmed_up']})"
                            self.logger.info(f"[{self.symbol}] ðŸŸ¢ CONFIRMED BUY: {signal_reason}")
                        else:
                            self.logger.info(f"[{self.symbol}] CONFIRMED BUY blocked: Signal stability period")
                    else:
                        self.logger.info(f"[{self.symbol}] CONFIRMED BUY blocked: QQE too high ({current_qqe_value:.2f} >= {self.qqe_long_entry_max_zone})")

                # FIXED: Confirmed SELL - QQE confirmed BEARISH + ST confirmed DOWN
                elif qqe_result['confirmed_bearish'] and supertrend_result['confirmed_down']:
                    if current_qqe_value > self.qqe_short_entry_min_zone:
                        if allow_opposite or self.last_signal != 'buy':
                            signal = 'sell'
                            signal_tier = 'confirmed'
                            signal_reason = f"QQE confirmed bearish ({qqe_result['confirmed_bearish']}) + ST confirmed down ({supertrend_result['confirmed_down']})"
                            self.logger.info(f"[{self.symbol}] ðŸ”´ CONFIRMED SELL: {signal_reason}")
                        else:
                            self.logger.info(f"[{self.symbol}] CONFIRMED SELL blocked: Signal stability period")
                    else:
                        self.logger.info(f"[{self.symbol}] CONFIRMED SELL blocked: QQE too low ({current_qqe_value:.2f} <= {self.qqe_short_entry_min_zone})")

            # TIER 3: IMMEDIATE SIGNALS (only if very strong alignment and high volatility)
            if signal == 'none' and self.volatility_level == 'high':
                if (qqe_result['immediate_bullish'] and supertrend_result['immediate_up'] and 
                    qqe_result['qqe_direction'] > 0.5):
                    if current_qqe_value < self.qqe_long_entry_max_zone:
                        if allow_opposite or self.last_signal != 'sell':
                            signal = 'buy'
                            signal_tier = 'immediate'
                            signal_reason = f"High volatility breakout: QQE immediate bullish + strong momentum"
                            self.logger.info(f"[{self.symbol}] ðŸŸ¢ IMMEDIATE BUY: {signal_reason}")

                elif (qqe_result['immediate_bearish'] and supertrend_result['immediate_down'] and 
                      qqe_result['qqe_direction'] < -0.5):
                    if current_qqe_value > self.qqe_short_entry_min_zone:
                        if allow_opposite or self.last_signal != 'buy':
                            signal = 'sell'
                            signal_tier = 'immediate'
                            signal_reason = f"High volatility breakdown: QQE immediate bearish + strong momentum"
                            self.logger.info(f"[{self.symbol}] ðŸ”´ IMMEDIATE SELL: {signal_reason}")

            # ENHANCED NO SIGNAL LOGGING
            if signal == 'none':
                # Check what's preventing signals
                blockers = []
                
                # Check QQE conditions
                if not any([qqe_result['fast_bullish'], qqe_result['fast_bearish'], 
                          qqe_result['confirmed_bullish'], qqe_result['confirmed_bearish']]):
                    blockers.append("No QQE bullish/bearish signals")
                
                # Check ST conditions  
                if not any([supertrend_result['fast_up'], supertrend_result['fast_down'],
                          supertrend_result['confirmed_up'], supertrend_result['confirmed_down']]):
                    blockers.append("No ST up/down confirmation")
                
                # Check misalignment
                if ((qqe_result['confirmed_bullish'] or qqe_result['fast_bullish']) and 
                    not (supertrend_result['confirmed_up'] or supertrend_result['fast_up'])):
                    blockers.append(f"QQE bullish but ST not up (ST dir: {supertrend_result['direction']})")
                
                if ((qqe_result['confirmed_bearish'] or qqe_result['fast_bearish']) and 
                    not (supertrend_result['confirmed_down'] or supertrend_result['fast_down'])):
                    blockers.append(f"QQE bearish but ST not down (ST dir: {supertrend_result['direction']})")
                
                # Check zone restrictions
                if (qqe_result['confirmed_bullish'] or qqe_result['fast_bullish']) and current_qqe_value >= self.qqe_long_entry_max_zone:
                    blockers.append(f"QQE too high for long ({current_qqe_value:.2f} >= {self.qqe_long_entry_max_zone})")
                
                if (qqe_result['confirmed_bearish'] or qqe_result['fast_bearish']) and current_qqe_value <= self.qqe_short_entry_min_zone:
                    blockers.append(f"QQE too low for short ({current_qqe_value:.2f} <= {self.qqe_short_entry_min_zone})")
                
                if not allow_opposite:
                    blockers.append(f"Signal stability period active ({time_since_last:.1f}s < {self.signal_stability_period}s)")
                
                self.logger.info(f"[{self.symbol}] âŒ No signal generated. Blockers: {'; '.join(blockers) if blockers else 'Unknown'}")
                
            else:
                self.logger.info(f"[{self.symbol}] âœ… SIGNAL GENERATED: {signal.upper()} ({signal_tier} tier)")
                self.logger.info(f"[{self.symbol}] âœ… REASON: {signal_reason}")

            return signal
            
        except Exception as e:
            self.logger.error(f"[{self.symbol}] âŒ Error in responsive signal generation: {e}", exc_info=True)
            return 'none'

    def evaluate_exit_conditions(self, position_side: str, entry_price: float, current_price: float) -> Dict:
        try:
            result = {'should_exit': False, 'exit_reason': '', 'exit_urgency': 'none'}
            self.logger.info(f"[{self.symbol}] Evaluating exit for {position_side} @ entry ${entry_price:.6f}, current ${current_price:.6f}")
            
            qqe_data = self.last_indicators.get('qqe')
            st_data = self.last_indicators.get('supertrend')
            
            if not qqe_data or not st_data:
                self.logger.info(f"[{self.symbol}] Missing QQE or Supertrend data for exit eval.")
                return result

            pnl_pct = 0.0
            if entry_price != 0:
                pnl_pct = ((current_price - entry_price) / entry_price) * 100 if position_side == 'long' else ((entry_price - current_price) / entry_price) * 100
            
            entry_time = getattr(self, 'position_entry_time', 0) 
            position_age_seconds = time.time() - entry_time if entry_time > 0 else 99999
            min_pos_time_for_signal_exit = 60 

            if pnl_pct < -3.0: 
                result.update({'should_exit': True, 'exit_reason': f"EMERGENCY SL: PnL {pnl_pct:.2f}%", 'exit_urgency': 'immediate'})
                return result

            if position_side == 'long' and qqe_data.get('is_bearish_cross', False):
                if position_age_seconds >= min_pos_time_for_signal_exit or pnl_pct < -1.0: 
                    result.update({'should_exit': True, 'exit_reason': f"QQE Bearish Cross (PnL {pnl_pct:.2f}%)", 'exit_urgency': 'normal'})
                    return result
            elif position_side == 'short' and qqe_data.get('is_bullish_cross', False):
                 if position_age_seconds >= min_pos_time_for_signal_exit or pnl_pct < -1.0:
                    result.update({'should_exit': True, 'exit_reason': f"QQE Bullish Cross (PnL {pnl_pct:.2f}%)", 'exit_urgency': 'normal'})
                    return result

            if position_side == 'long' and st_data.get('direction') == 'down' and st_data.get('changed', False):
                 if position_age_seconds >= min_pos_time_for_signal_exit or pnl_pct < -0.5: 
                    result.update({'should_exit': True, 'exit_reason': f"Supertrend Flipped DOWN (PnL {pnl_pct:.2f}%)", 'exit_urgency': 'normal'})
                    return result
            elif position_side == 'short' and st_data.get('direction') == 'up' and st_data.get('changed', False):
                if position_age_seconds >= min_pos_time_for_signal_exit or pnl_pct < -0.5:
                    result.update({'should_exit': True, 'exit_reason': f"Supertrend Flipped UP (PnL {pnl_pct:.2f}%)", 'exit_urgency': 'normal'})
                    return result
            return result
        except Exception as e:
            self.logger.error(f"[{self.symbol}] âŒ Error evaluating exit conditions: {e}", exc_info=True)
            return {'should_exit': False, 'exit_reason': 'Error in eval', 'exit_urgency': 'none'}

    # In AdaptiveCryptoSignals class

    # In AdaptiveCryptoSignals class

    def _calculate_qqe(self, df: pd.DataFrame) -> Optional[Dict]:
        """
        RESPONSIVE QQE: Fast response with quality filters.
        Designed for crypto speed while avoiding whipsaws.
        """
        try:
            qqe_df = ta.qqe(df['close'], 
                            length=self.params.qqe_length, 
                            smooth=self.params.qqe_smooth, 
                            factor=self.params.qqe_factor)
            
            if qqe_df is None or qqe_df.empty:
                return None

            # Column identification (same as before)
            factor_str_for_name = str(self.params.qqe_factor) 
            base_col_name = f"QQE_{self.params.qqe_length}_{self.params.qqe_smooth}_{factor_str_for_name}"
            
            qqe_line_col_name = base_col_name
            qqe_signal_col_name = f"{base_col_name}_RSIMA"

            if qqe_line_col_name not in qqe_df.columns:
                if len(qqe_df.columns) > 0: 
                    qqe_line_col_name = qqe_df.columns[0]
                else: 
                    return None
            
            if qqe_signal_col_name not in qqe_df.columns:
                if len(qqe_df.columns) > 1: 
                    qqe_signal_col_name = qqe_df.columns[1]
                else: 
                    return None

            qqe_line_series = qqe_df[qqe_line_col_name]
            qqe_signal_series = qqe_df[qqe_signal_col_name]

            if len(qqe_line_series) < 3:  # Reduced from 5 to 3
                return None
            
            # Current values
            cv = float(qqe_line_series.iloc[-1])  # Current yellow line
            cs = float(qqe_signal_series.iloc[-1])  # Current signal line
            pv = float(qqe_line_series.iloc[-2])  # Previous yellow line
            ps = float(qqe_signal_series.iloc[-2])  # Previous signal line
            
            if pd.isna(cv) or pd.isna(cs) or pd.isna(pv) or pd.isna(ps):
                return None

            # RESPONSIVE LOGIC: Multiple signal tiers for different speed/quality tradeoffs
            
            # Tier 1: IMMEDIATE - Position-based (current period only)
            immediate_bullish = cv > cs  # Yellow above signal line NOW
            immediate_bearish = cv < cs  # Yellow below signal line NOW
            
            # Tier 2: FAST - Position + momentum (1 period confirmation)
            qqe_direction = cv - pv  # Recent direction
            fast_bullish = immediate_bullish and qqe_direction > 0  # Above + rising
            fast_bearish = immediate_bearish and qqe_direction < 0  # Below + falling
            
            # Tier 3: CONFIRMED - Sustained position (2 periods, not 3)
            if len(qqe_line_series) >= 3:
                prev2_qqe = float(qqe_line_series.iloc[-3])
                prev2_signal = float(qqe_signal_series.iloc[-3])
                
                above_count = sum([cv > cs, pv > ps, prev2_qqe > prev2_signal])
                below_count = sum([cv < cs, pv < ps, prev2_qqe < prev2_signal])
                
                confirmed_bullish = above_count >= 2  # 2 of last 3 periods
                confirmed_bearish = below_count >= 2  # 2 of last 3 periods
            else:
                confirmed_bullish = immediate_bullish
                confirmed_bearish = immediate_bearish

            # Signal strength classification
            if confirmed_bullish and fast_bullish:
                signal_strength = 'confirmed_strong'
            elif confirmed_bearish and fast_bearish:
                signal_strength = 'confirmed_strong'
            elif confirmed_bullish:
                signal_strength = 'confirmed'
            elif confirmed_bearish:
                signal_strength = 'confirmed'
            elif fast_bullish:
                signal_strength = 'fast'
            elif fast_bearish:
                signal_strength = 'fast'
            elif immediate_bullish or immediate_bearish:
                signal_strength = 'immediate'
            else:
                signal_strength = 'neutral'

            self.logger.debug(f"[{self.symbol}] QQE Responsive: Yellow={cv:.2f}, Signal={cs:.2f}, "
                            f"Immediate: Bull={immediate_bullish}, Bear={immediate_bearish}, "
                            f"Fast: Bull={fast_bullish}, Bear={fast_bearish}, "
                            f"Confirmed: Bull={confirmed_bullish}, Bear={confirmed_bearish}, "
                            f"Strength={signal_strength}")

            return {
                'qqe_value': cv,
                'qqe_signal_line_value': cs,
                'qqe_direction': qqe_direction,
                
                # Immediate tier (0 periods delay)
                'immediate_bullish': immediate_bullish,
                'immediate_bearish': immediate_bearish,
                
                # Fast tier (1 period, 3 minutes delay)
                'fast_bullish': fast_bullish,
                'fast_bearish': fast_bearish,
                
                # Confirmed tier (2 periods, 6 minutes delay max)
                'confirmed_bullish': confirmed_bullish,
                'confirmed_bearish': confirmed_bearish,
                
                'signal_strength': signal_strength
            }
            
        except Exception as e:
            self.logger.error(f"[{self.symbol}] QQE responsive calculation error: {e}", exc_info=True)
            return None

    def _calculate_supertrend(self, df: pd.DataFrame) -> Optional[Dict]:
        """
        RESPONSIVE SUPERTREND: Faster confirmation for crypto speed.
        """
        try:
            st_df = ta.supertrend(high=df['high'], low=df['low'], close=df['close'], 
                               length=self.params.supertrend_period, 
                               multiplier=self.params.supertrend_multiplier)
            
            if st_df is None or st_df.empty:
                return None

            # Find direction column
            dir_col_name = f"SUPERTd_{self.params.supertrend_period}_{self.params.supertrend_multiplier}"
            if dir_col_name not in st_df.columns:
                dir_col_name = next((col for col in st_df.columns if 'SUPERTd' in col), None)
                if not dir_col_name:
                    return None
            
            st_directions = st_df[dir_col_name]

            if len(st_directions) < 3:  # Reduced from 5 to 3
                return None

            # Current and recent directions
            current_dir = int(st_directions.iloc[-1])
            prev_dir = int(st_directions.iloc[-2])
            
            # RESPONSIVE LOGIC: Faster confirmation for crypto
            
            # Immediate: Current direction only
            immediate_up = current_dir == 1
            immediate_down = current_dir == -1
            
            # Fast: Current + no recent flip (1 period stability)
            fast_up = immediate_up and prev_dir == 1  # 2 consecutive up periods
            fast_down = immediate_down and prev_dir == -1  # 2 consecutive down periods
            
            # Confirmed: 3 periods max (reduced from 4)
            if len(st_directions) >= 3:
                prev2_dir = int(st_directions.iloc[-3])
                recent_dirs = [current_dir, prev_dir, prev2_dir]
                
                up_count = sum(1 for d in recent_dirs if d == 1)
                down_count = sum(1 for d in recent_dirs if d == -1)
                
                confirmed_up = up_count >= 2  # 2 of last 3 periods
                confirmed_down = down_count >= 2  # 2 of last 3 periods
            else:
                confirmed_up = fast_up
                confirmed_down = fast_down

            # Just changed detection
            just_changed = current_dir != prev_dir
            
            direction = 'up' if current_dir == 1 else 'down'
            
            # Trend strength classification
            if confirmed_up and fast_up:
                trend_strength = 'confirmed_strong'
            elif confirmed_down and fast_down:
                trend_strength = 'confirmed_strong'
            elif confirmed_up:
                trend_strength = 'confirmed'
            elif confirmed_down:
                trend_strength = 'confirmed'
            elif fast_up or fast_down:
                trend_strength = 'fast'
            else:
                trend_strength = 'immediate'

            self.logger.debug(f"[{self.symbol}] Supertrend Responsive: Dir={direction}, "
                            f"Immediate: Up={immediate_up}, Down={immediate_down}, "
                            f"Fast: Up={fast_up}, Down={fast_down}, "
                            f"Confirmed: Up={confirmed_up}, Down={confirmed_down}, "
                            f"Strength={trend_strength}, Changed={just_changed}")

            return {
                'direction': direction,
                'current_value': current_dir,
                'just_changed': just_changed,
                
                # Immediate tier
                'immediate_up': immediate_up,
                'immediate_down': immediate_down,
                
                # Fast tier (3 minutes delay)
                'fast_up': fast_up,
                'fast_down': fast_down,
                
                # Confirmed tier (6 minutes delay max)
                'confirmed_up': confirmed_up,
                'confirmed_down': confirmed_down,
                
                'trend_strength': trend_strength
            }
            
        except Exception as e:
            self.logger.error(f"[{self.symbol}] Supertrend responsive calculation error: {e}", exc_info=True)
            return None

    def _update_volatility_level(self, df: pd.DataFrame): 
        try:
            atr = ta.atr(high=df['high'], low=df['low'], close=df['close'], length=14) 
            if atr is not None and len(atr.dropna()) > 0:
                curr_atr = float(atr.dropna().iloc[-1])
                price = float(df['close'].iloc[-1])
                if price == 0: self.volatility_level = 'normal'; return
                atr_pct = (curr_atr / price) * 100
                self.volatility_level = 'high' if atr_pct > 2.0 else 'low' if atr_pct < 0.5 else 'normal'
            else: self.volatility_level = 'normal'      
        except Exception: self.volatility_level = 'normal'

    def _track_signal(self, signal: str, price: float):
        try:
            signal_data = {
                'signal': signal, 'price': price, 'timestamp': time.time(),
                'params': { 
                    'qqe_length': self.params.qqe_length, 'qqe_smooth': self.params.qqe_smooth,
                    'supertrend_period': self.params.supertrend_period, 'supertrend_multiplier': self.params.supertrend_multiplier
                },
                'market_state': {'trend': self.current_trend, 'volatility': self.volatility_level}
            }
            self.signal_performance.append(signal_data)
            self._evaluate_signals()
            if len(self.signal_performance) % 5 == 0: self._save_config()
        except Exception as e: self.logger.error(f"[{self.symbol}] Error tracking signal: {e}", exc_info=True)

    def _evaluate_signals(self):
        try:
            current_time = time.time(); eval_period_s = 30 * 60; min_move_pct = 0.5; eval_count = 0
            for sig_data in list(self.signal_performance): 
                if sig_data.get('evaluated', False): continue
                if current_time - sig_data['timestamp'] < eval_period_s: continue
                
                fut_price = None; fut_ts = float('inf')
                for fut_cand in self.signal_performance:
                    cand_ts = fut_cand['timestamp']
                    if cand_ts >= (sig_data['timestamp'] + eval_period_s) and cand_ts < fut_ts:
                        fut_price = fut_cand['price']; fut_ts = cand_ts
                
                if fut_price is not None:
                    chg_pct = ((fut_price - sig_data['price']) / sig_data['price']) * 100 if sig_data['price'] != 0 else 0
                    sig_data['correct'] = (sig_data['signal'] == 'buy' and chg_pct > min_move_pct) or \
                                          (sig_data['signal'] == 'sell' and chg_pct < -min_move_pct)
                    sig_data['evaluated'] = True; sig_data['price_change_eval'] = chg_pct; eval_count += 1
            
            tot_eval = sum(1 for s in self.signal_performance if s.get('evaluated', False))
            tot_corr = sum(1 for s in self.signal_performance if s.get('correct', False))
            self.params.accuracy = (tot_corr / tot_eval) * 100 if tot_eval > 0 else 0.0
            self.params.total_signals = tot_eval; self.params.winning_signals = tot_corr
            if eval_count > 0: self.logger.info(f"[{self.symbol}] Evaluated {eval_count} signals. Accuracy: {self.params.accuracy:.2f}%")
        except Exception as e: self.logger.error(f"[{self.symbol}] Error evaluating signals: {e}", exc_info=True)

    def _should_optimize(self) -> bool:
        curr_time = time.time()
        if curr_time - self.last_optimization < self.optimization_interval: return False
        if self.params.total_signals >= self.min_signals_for_optimization and self.params.accuracy < 45.0: return True
        return False

    def _optimize_parameters(self, df: pd.DataFrame):
        try:
            self.logger.info(f"[{self.symbol}] ðŸ”§ Optimizing QQE & ST parameters...")
            param_ranges = {
                'qqe_length': [10, 14, 20], 'qqe_smooth': [3, 5, 7],
                'supertrend_period': [7, 10, 14], 'supertrend_multiplier': [2.0, 3.0]
            }
            best_score = -1.0; best_params_dict = None; num_combos = 0

            for q_len in param_ranges['qqe_length']:
              for q_sm in param_ranges['qqe_smooth']:
                for st_p in param_ranges['supertrend_period']:
                  for st_m in param_ranges['supertrend_multiplier']:
                    num_combos +=1
                    test_p = SignalParameters( qqe_length=q_len, qqe_smooth=q_sm,
                                               supertrend_period=st_p, supertrend_multiplier=st_m)
                    score = self._quick_backtest(df.copy(), test_p) 
                    self.logger.info(f"[{self.symbol}] Opt Test: Q({q_len},{q_sm}), ST({st_p},{st_m}) -> Score: {score:.2f}%")
                    if score > best_score:
                        best_score = score
                        best_params_dict = {
                            'qqe_length': q_len, 'qqe_smooth': q_sm,
                            'supertrend_period': st_p, 'supertrend_multiplier': st_m
                        }
            
            self.logger.info(f"[{self.symbol}] Optimization tested {num_combos} combos. Best backtest score: {best_score:.2f}%")
            if best_params_dict and best_score > self.params.accuracy : # Only update if backtest score is better than current live accuracy
                self.logger.info(f"[{self.symbol}] ðŸ“ˆ New best QQE/ST parameters found (Score: {best_score:.2f}% vs Current Acc: {self.params.accuracy:.2f}%). Updating live parameters.")
                self.params.qqe_length = best_params_dict['qqe_length']
                self.params.qqe_smooth = best_params_dict['qqe_smooth']
                self.params.supertrend_period = best_params_dict['supertrend_period']
                self.params.supertrend_multiplier = best_params_dict['supertrend_multiplier']
                self.params.accuracy = 0.0; self.params.total_signals = 0; self.params.winning_signals = 0 # Reset accuracy for new params
                self.params.last_used = time.time()
                self.signal_performance.clear()
                self._save_config()
            self.last_optimization = time.time()
        except Exception as e: self.logger.error(f"[{self.symbol}] Error optimizing parameters: {e}", exc_info=True)

    def _quick_backtest(self, df_hist: pd.DataFrame, params_to_test: SignalParameters) -> float:
        try:
            df_calc = df_hist.set_index('timestamp')
            qqe_bt_df = ta.qqe(df_calc['close'], length=params_to_test.qqe_length, smooth=params_to_test.qqe_smooth, factor=4.236)
            if qqe_bt_df is None or qqe_bt_df.empty or len(qqe_bt_df.columns) < 2: return 0.0
            df_calc['qqe_val'] = qqe_bt_df.iloc[:,0]
            df_calc['qqe_sig'] = qqe_bt_df.iloc[:,1]
            
            st_bt_df = ta.supertrend(df_calc['high'], df_calc['low'], df_calc['close'], 
                                   length=params_to_test.supertrend_period, multiplier=params_to_test.supertrend_multiplier)
            if st_bt_df is None or st_bt_df.empty: return 0.0
            st_dir_col = next((col for col in st_bt_df.columns if 'SUPERTd' in col), None)
            if not st_dir_col: return 0.0
            df_calc['st_dir'] = st_bt_df[st_dir_col]

            df_calc.dropna(inplace=True)
            if len(df_calc) < 30: return 0.0

            trades = 0; wins = 0; position = None; entry_price = 0.0
            tp_pct = 1.5; sl_pct = 1.0 

            for i in range(1, len(df_calc)):
                price = df_calc['close'].iloc[i]
                if position == 'long':
                    qqe_bear_cross = df_calc['qqe_val'].iloc[i] < df_calc['qqe_sig'].iloc[i] and \
                                     df_calc['qqe_val'].iloc[i-1] >= df_calc['qqe_sig'].iloc[i-1]
                    if price >= entry_price * (1 + tp_pct/100) or qqe_bear_cross:
                        wins += 1 if (price >= entry_price * (1 + tp_pct/100) or (qqe_bear_cross and price > entry_price)) else 0
                        trades += 1; position = None; continue
                    elif price <= entry_price * (1 - sl_pct/100):
                        trades += 1; position = None; continue
                elif position == 'short':
                    qqe_bull_cross = df_calc['qqe_val'].iloc[i] > df_calc['qqe_sig'].iloc[i] and \
                                     df_calc['qqe_val'].iloc[i-1] <= df_calc['qqe_sig'].iloc[i-1]
                    if price <= entry_price * (1 - tp_pct/100) or qqe_bull_cross:
                        wins += 1 if (price <= entry_price * (1 - tp_pct/100) or (qqe_bull_cross and price < entry_price)) else 0
                        trades += 1; position = None; continue
                    elif price >= entry_price * (1 + sl_pct/100):
                        trades += 1; position = None; continue
                
                if not position:
                    cv, pv = df_calc['qqe_val'].iloc[i], df_calc['qqe_val'].iloc[i-1]
                    cs, ps = df_calc['qqe_sig'].iloc[i], df_calc['qqe_sig'].iloc[i-1]
                    b_x = pv <= ps and cv > cs; b_mom = cv > cs and cv > pv
                    s_x = pv >= ps and cv < cs; s_mom = cv < cs and cv < pv
                    qqe_long = b_x or b_mom; qqe_short = s_x or s_mom
                    st_up = df_calc['st_dir'].iloc[i] == 1
                    
                    if qqe_long and st_up and cv < self.qqe_long_entry_max_zone: # Using self. for zone defaults
                        position = 'long'; entry_price = price
                    elif qqe_short and not st_up and cv > self.qqe_short_entry_min_zone:
                        position = 'short'; entry_price = price
            return (wins / trades) * 100.0 if trades > 0 else 0.0
        except Exception as e:
            self.logger.error(f"[{self.symbol}] Error in _quick_backtest: {e}", exc_info=True)
            return 0.0

    def _load_symbol_config(self) -> SignalParameters:
        try:
            if os.path.exists(self.config_file):
                with open(self.config_file, 'r') as f: configs = json.load(f)
                if self.symbol in configs:
                    cfg = configs[self.symbol]
                    return SignalParameters(
                        qqe_length=cfg.get('qqe_length', SignalParameters.qqe_length),
                        qqe_smooth=cfg.get('qqe_smooth', SignalParameters.qqe_smooth),
                        qqe_factor=cfg.get('qqe_factor', SignalParameters.qqe_factor), # Safely get qqe_factor
                        supertrend_period=cfg.get('supertrend_period', SignalParameters.supertrend_period),
                        supertrend_multiplier=cfg.get('supertrend_multiplier', SignalParameters.supertrend_multiplier),
                        accuracy=cfg.get('accuracy', 0.0), total_signals=cfg.get('total_signals',0), 
                        winning_signals=cfg.get('winning_signals',0), last_used=cfg.get('last_used', 0.0)
                    )
        except Exception as e: self.logger.error(f"[{self.symbol}] Error loading config: {e}. Defaults used.", exc_info=True)
        return SignalParameters()

    def _load_signal_history(self) -> deque:
        try:
            if os.path.exists(self.config_file):
                with open(self.config_file, 'r') as f: configs = json.load(f)
                if self.symbol in configs:
                    hist = configs[self.symbol].get('signal_history', [])
                    return deque([item for item in hist if isinstance(item, dict)][-100:], maxlen=100)
        except Exception as e: self.logger.error(f"[{self.symbol}] Error loading history: {e}. Fresh history.", exc_info=True)
        return deque(maxlen=100)

    def _save_config(self):
        try:
            configs = {}
            if os.path.exists(self.config_file):
                try: 
                    with open(self.config_file, 'r') as f: configs = json.load(f)
                except json.JSONDecodeError: self.logger.warning(f"Config {self.config_file} corrupted. Overwriting."); configs = {}
            
            configs[self.symbol] = {
            'qqe_length': self.params.qqe_length, 
            'qqe_smooth': self.params.qqe_smooth, 
            'qqe_factor': self.params.qqe_factor, # Ensure it's saved
            'supertrend_period': self.params.supertrend_period, 
            'supertrend_multiplier': self.params.supertrend_multiplier,
            'accuracy': self.params.accuracy, 
            'total_signals': self.params.total_signals, 
            'winning_signals': self.params.winning_signals, 
            'last_used': self.params.last_used,
            'signal_history': list(self.signal_performance)[-100:], # Ensure deque is converted to list
            'last_updated': time.time()
        }
            config_dir = os.path.dirname(self.config_file)
            if config_dir and not os.path.exists(config_dir): os.makedirs(config_dir, exist_ok=True)
            temp_file = self.config_file + '.tmp'
            with open(temp_file, 'w') as f: json.dump(configs, f, indent=2)
            os.replace(temp_file, self.config_file)
        except Exception as e: self.logger.error(f"[{self.symbol}] Error saving config: {e}", exc_info=True)

    def get_system_status(self) -> Dict:
        return {
            'system_type': 'QQE_Supertrend_Only',
            'params': { 
                'qqe_length': self.params.qqe_length, 'qqe_smooth': self.params.qqe_smooth,
                'supertrend_period': self.params.supertrend_period, 'supertrend_multiplier': self.params.supertrend_multiplier,
            },
            'performance': {'accuracy': self.params.accuracy, 'total_signals': self.params.total_signals, 'winning_signals': self.params.winning_signals},
            'market_state': {'trend': self.current_trend, 'volatility': self.volatility_level}, 
            'last_signal_info': {'signal': self.last_signal, 'time': self.last_signal_time },
            'exit_logic_provider': 'External Strategy + QQE/ST reasons from this module'
        }

def integrate_adaptive_crypto_signals(strategy_instance, config_file: str = None):
    if config_file is None: config_file = os.path.join(os.getcwd(), "data", "crypto_signal_configs.json")
    strategy_instance.logger.info(f"ðŸ”§ Integrating QQE & Supertrend ONLY Crypto Signals, config: {config_file}")
    base_sym = getattr(strategy_instance, 'original_symbol', strategy_instance.symbol)
    crypto_sigs = AdaptiveCryptoSignals(symbol=base_sym, config_file=config_file)
    
    strategy_instance._get_technical_direction = lambda: crypto_sigs.get_technical_direction(strategy_instance.exchange)
    strategy_instance.get_signal_status = crypto_sigs.get_system_status
    strategy_instance.test_crypto_indicators = lambda: crypto_sigs.test_indicators(strategy_instance.exchange)
    strategy_instance._crypto_signal_system = crypto_sigs
    
    try:
        strategy_instance.logger.info(f"Initial indicator test for {base_sym} (QQE/ST Only)...")
        test_res = strategy_instance.test_crypto_indicators()
        # Log test_res details if needed, for brevity, just confirming success/failure
        if isinstance(test_res, dict) and 'error' not in test_res:
             strategy_instance.logger.info(f"ðŸ“Š Indicator Test (QQE/ST Only) for {base_sym} successful. Signal sim: {test_res.get('composite_signal_sim', 'N/A')}")
        else:
            strategy_instance.logger.warning(f"ðŸ“Š Indicator Test (QQE/ST Only) for {base_sym} may have issues: {test_res}")

    except Exception as e: strategy_instance.logger.error(f"Failed initial indicator test (QQE/ST Only): {e}", exc_info=True)
    
    strategy_instance.logger.info("âš¡ QQE & Supertrend ONLY Crypto Signals integrated!")
    return crypto_sigs

def test_indicators(self: AdaptiveCryptoSignals, exchange) -> Dict:
    try:
        ohlcv = exchange.get_ohlcv(self.symbol, timeframe='3m', limit=300)
        if not ohlcv or len(ohlcv) < 50: return {'error': f'Insufficient data: {len(ohlcv) if ohlcv else 0}'}
        
        df = pd.DataFrame(ohlcv, columns=['timestamp', 'open', 'high', 'low', 'close', 'volume'])
        df['timestamp'] = pd.to_datetime(df['timestamp'], unit='ms')
        df_idx = df.set_index('timestamp')
        for col in ['open', 'high', 'low', 'close', 'volume']: df_idx[col] = df_idx[col].astype(float)

        res = {'symbol': self.symbol, 'price': float(df_idx['close'].iloc[-1]), 'data_points': len(df_idx)}
        res['qqe_calc_result'] = self._calculate_qqe(df_idx) or 'Failed QQE Calc' # Store full dict
        res['supertrend_calc_result'] = self._calculate_supertrend(df_idx) or 'Failed ST Calc' # Store full dict
        res['composite_signal_simulated'] = self._generate_composite_signal(df_idx) 
        res['current_market_trend_ST'] = self.current_trend 
        res['current_volatility_ATR'] = self.volatility_level 
        return res
    except Exception as e:
        self.logger.error(f"[{self.symbol}] Error in test_indicators (QQE/ST): {e}", exc_info=True)
        return {'error': str(e)}

AdaptiveCryptoSignals.test_indicators = test_indicators
integrate_crypto_signals = integrate_adaptive_crypto_signals

